<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Product Hierarchy Visualization - Revenue Cloud Migration</title>
    <!-- 
    ╔═══════════════════════════════════════════════════════════════════════════════╗
    ║ CRITICAL REQUIREMENT: COLLAPSED STATE ON LOAD                                ║
    ║                                                                               ║
    ║ This visualization MUST always load with the hierarchy in a collapsed state.  ║
    ║ Only top-level catalogs should be visible initially.                         ║
    ║ Users must manually expand nodes to see their children.                      ║
    ║                                                                               ║
    ║ DO NOT CHANGE THIS BEHAVIOR WITHOUT EXPLICIT AUTHORIZATION                    ║
    ╚═══════════════════════════════════════════════════════════════════════════════╝
    -->
    
    <!-- CSS Libraries -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <link href="https://unpkg.com/antd@5.12.8/dist/reset.css" rel="stylesheet">
    <link rel="stylesheet" href="/static/css/style.css">
    <link rel="stylesheet" href="/static/css/edit-indicators.css">
    
    <!-- D3.js for visualizations -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    
    <!-- React and Ant Design for UI components -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/antd@5.12.8/dist/antd.min.js"></script>
    
    <!-- Edit functionality scripts -->
    <script src="/static/js/inline-edit.js"></script>
    <script src="/static/js/change-tracker.js?v=20250728_fix_circular"></script>
    <script src="/static/js/product-hierarchy-sync.js"></script>
    <script src="/static/js/add-node-manager.js"></script>
    
    <style>
        :root {
            --primary-color: #0176D3;
            --secondary-color: #014486;
            --success-color: #2E844A;
            --warning-color: #FFB75D;
            --error-color: #BA0517;
            --background-color: #F3F3F3;
            --surface-color: #FFFFFF;
            --text-primary: #181818;
            --text-secondary: #514F4D;
            --border-color: #DDDBDA;
            --shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            --shadow-hover: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: var(--background-color);
            color: var(--text-primary);
            line-height: 1.6;
        }

        .header {
            background-color: var(--surface-color);
            border-bottom: 1px solid var(--border-color);
            padding: 1rem 2rem;
            box-shadow: var(--shadow);
        }

        .header-content {
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header h1 {
            font-size: 1.5rem;
            font-weight: 600;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .header-actions {
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        .btn {
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 4px;
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
        }

        .btn-primary {
            background-color: var(--primary-color);
            color: white;
        }

        .btn-primary:hover {
            background-color: var(--secondary-color);
        }

        .btn-secondary {
            background-color: transparent;
            color: var(--primary-color);
            border: 1px solid var(--primary-color);
        }

        .btn-secondary:hover {
            background-color: var(--primary-color);
            color: white;
        }
        
        /* Ant Design Select styling to match our button style */
        #org-selector-container .ant-select {
            min-width: 200px;
        }
        
        #org-selector-container .ant-select-selector {
            background-color: transparent !important;
            color: var(--primary-color) !important;
            border: 1px solid var(--primary-color) !important;
            height: auto !important;
            padding: 0.5rem 1rem !important;
            border-radius: 4px !important;
            font-size: 0.875rem !important;
        }
        
        #org-selector-container .ant-select:hover .ant-select-selector {
            background-color: var(--primary-color) !important;
            color: white !important;
            border-color: var(--primary-color) !important;
        }
        
        #org-selector-container .ant-select:hover .ant-select-arrow {
            color: white !important;
        }
        
        #org-selector-container .ant-select-arrow {
            color: var(--primary-color);
        }
        
        /* Force dropdown to open downward and ensure visibility */
        .ant-select-dropdown {
            z-index: 10000 !important;
        }
        
        /* Add space below header for dropdown */
        .header {
            overflow: visible !important;
        }
        
        .header-actions {
            overflow: visible !important;
        }
        
        /* Organization selector wrapper and label */
        .org-selector-wrapper {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .field-label {
            font-size: 0.875rem;
            font-weight: 500;
            color: var(--text-dark);
            white-space: nowrap;
        }

        .main-container {
            width: 100%;
            margin: 0;
            padding: 1rem;
            display: flex;
            gap: 1rem;
            height: calc(100vh - 120px);
        }

        .visualization-panel {
            flex: 1;
            background-color: var(--surface-color);
            border-radius: 8px;
            box-shadow: var(--shadow);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .visualization-header {
            padding: 1rem;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .visualization-controls {
            display: flex;
            gap: 0.5rem;
        }

        .control-btn {
            width: 32px;
            height: 32px;
            border: 1px solid var(--border-color);
            background-color: var(--surface-color);
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .control-btn:hover {
            background-color: var(--background-color);
            border-color: var(--primary-color);
            color: var(--primary-color);
        }

        #hierarchy-container {
            flex: 1;
            position: relative;
            background-color: #FAFAFA;
        }

        .details-panel {
            width: 400px;
            background-color: var(--surface-color);
            border-radius: 8px;
            box-shadow: var(--shadow);
            display: flex;
            flex-direction: column;
            transition: transform 0.3s ease;
        }

        .details-panel.collapsed {
            transform: translateX(420px);
        }

        .details-header {
            padding: 1rem;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .details-content {
            flex: 1;
            overflow-y: auto;
            padding: 1.5rem;
        }

        .details-section {
            margin-bottom: 2rem;
        }

        .details-section:last-child {
            margin-bottom: 0;
        }

        .section-title {
            font-size: 0.875rem;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            margin-bottom: 1rem;
            letter-spacing: 0.05em;
        }

        .detail-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 0;
            border-bottom: 1px solid var(--background-color);
        }

        .detail-item:last-child {
            border-bottom: none;
        }

        .detail-label {
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .detail-value {
            font-size: 0.875rem;
            font-weight: 500;
            color: var(--text-primary);
        }

        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(255, 255, 255, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .loading-spinner {
            width: 48px;
            height: 48px;
            border: 3px solid var(--border-color);
            border-top-color: var(--primary-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: var(--text-secondary);
        }

        .empty-state i {
            font-size: 3rem;
            margin-bottom: 1rem;
            opacity: 0.5;
        }

        .empty-state p {
            font-size: 1.125rem;
            margin-bottom: 1.5rem;
        }

        /* React Flow Custom Node Styles */
        .custom-node {
            background-color: var(--surface-color);
            border: 2px solid var(--border-color);
            border-radius: 8px;
            padding: 1rem;
            min-width: 200px;
            box-shadow: var(--shadow);
            transition: all 0.2s;
        }

        .custom-node:hover {
            box-shadow: var(--shadow-hover);
            border-color: var(--primary-color);
        }

        .custom-node.selected {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 2px rgba(1, 118, 211, 0.2);
        }

        .node-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
        }

        .node-icon {
            width: 24px;
            height: 24px;
            background-color: var(--primary-color);
            color: white;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.875rem;
        }

        .node-title {
            font-weight: 600;
            font-size: 0.875rem;
            color: var(--text-primary);
        }

        .node-stats {
            display: flex;
            gap: 1rem;
            margin-top: 0.5rem;
        }

        .node-stat {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .stat-value {
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--primary-color);
        }

        .stat-label {
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        /* Custom Edge Styles */
        .react-flow__edge-path {
            stroke: var(--border-color);
            stroke-width: 2;
        }

        .react-flow__edge-path:hover {
            stroke: var(--primary-color);
        }

        /* Toolbar */
        .toolbar {
            position: absolute;
            bottom: 1rem;
            left: 1rem;
            background-color: var(--surface-color);
            border-radius: 8px;
            box-shadow: var(--shadow);
            display: flex;
            gap: 0.25rem;
            padding: 0.5rem;
            z-index: 100;
        }

        .toolbar-btn {
            width: 36px;
            height: 36px;
            border: none;
            background-color: transparent;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .toolbar-btn:hover {
            background-color: var(--background-color);
        }

        .toolbar-btn.active {
            background-color: var(--primary-color);
            color: white;
        }


        /* Breadcrumb */
        .breadcrumb {
            padding: 0.75rem 1rem;
            background-color: var(--background-color);
            border-bottom: 1px solid var(--border-color);
            font-size: 0.875rem;
        }

        .breadcrumb-item {
            color: var(--text-secondary);
            text-decoration: none;
            transition: color 0.2s;
        }

        .breadcrumb-item:hover {
            color: var(--primary-color);
        }

        .breadcrumb-separator {
            margin: 0 0.5rem;
            color: var(--text-secondary);
        }

        .breadcrumb-current {
            color: var(--text-primary);
            font-weight: 500;
        }
        
        /* Column Headers */
        .column-header {
            position: absolute;
            top: 10px;
            text-align: center;
            width: 180px;
            font-size: 0.875rem;
            font-weight: 600;
            color: var(--text-primary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        
        .column-header-color {
            width: 100%;
            height: 4px;
            border-radius: 2px;
            margin-bottom: 6px;
        }
        
        /* Node dragging styles */
        .node.dragging rect {
            opacity: 0.8;
            filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.2));
        }
        
        .node {
            transition: none;
        }
        
        .link {
            pointer-events: none;
            transition: opacity 0.3s ease;
        }
        
        /* Highlight path to selected node */
        .link.highlight {
            stroke: #FF6900 !important; /* Orange color for active path */
            stroke-width: 3px !important;
            opacity: 1 !important;
        }
        
        /* Node hover states */
        .node rect {
            transition: none;
        }
        
        .node:hover rect {
            filter: brightness(1.1) drop-shadow(0 4px 8px rgba(0, 0, 0, 0.15));
            stroke-width: 2px;
        }
        
        /* Selected node styling */
        .node.selected rect {
            stroke-width: 3px !important;
            filter: brightness(1.15) drop-shadow(0 4px 12px rgba(0, 0, 0, 0.25));
        }
        
        .node.selected text {
            font-weight: 600;
        }
        
        /* Style for nodes shown only because they have visible children */
        .node-shown-for-children rect {
            opacity: 0.5;
            stroke-dasharray: 5,5;
        }
        
        .node-shown-for-children text {
            opacity: 0.6;
            font-style: italic;
        }
        
        /* Delete functionality styles */
        .node.pending-delete rect {
            opacity: 0.5 !important;
            stroke: #dc3545 !important;
            stroke-width: 2px !important;
            stroke-dasharray: 4,2 !important;
        }
        
        .node.pending-delete text {
            opacity: 0.7;
        }
        
        .deletion-indicator {
            fill: #dc3545;
            font-size: 11px;
            font-weight: bold;
            text-anchor: middle;
        }
        
        .node.inactive rect {
            opacity: 0.6;
            stroke-dasharray: 2,2;
        }
        
        .node.inactive text {
            opacity: 0.7;
            text-decoration: line-through;
        }
        
        /* Undo notification styles */
        .undo-notification {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: #333;
            color: white;
            padding: 12px 20px;
            border-radius: 4px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            display: flex;
            align-items: center;
            gap: 12px;
            z-index: 1000;
            animation: slideIn 0.3s ease-out;
        }
        
        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        .undo-notification button {
            background: none;
            border: 1px solid white;
            color: white;
            padding: 4px 12px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
        }
        
        .undo-notification button:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        
        /* Deletion dialog styles */
        .deletion-options {
            padding: 10px 0;
        }
        
        .deletion-option {
            margin-bottom: 15px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            transition: all 0.2s;
        }
        
        .deletion-option:hover {
            background: #f8f9fa;
            border-color: #0176D3;
        }
        
        .deletion-option input[type="radio"] {
            margin-right: 10px;
        }
        
        .deletion-option label {
            display: flex;
            flex-direction: column;
            cursor: pointer;
            margin-bottom: 0;
        }
        
        .deletion-option label strong {
            font-size: 14px;
            margin-bottom: 4px;
        }
        
        .option-description {
            font-size: 12px;
            color: #666;
            margin-left: 22px;
        }
        
        #parent-selector {
            margin-top: 10px;
            margin-left: 25px;
            display: none;
        }
        
        #parent-selector label {
            font-size: 13px;
            margin-bottom: 5px;
        }
        
        #parent-selector select {
            width: 100%;
            max-width: 400px;
        }
        
        /* Deletion row in change summary */
        .deletion-row {
            background-color: rgba(220, 53, 69, 0.05);
        }
        
        .deletion-row:hover {
            background-color: rgba(220, 53, 69, 0.1);
        }
        
        /* Progress bar styles */
        .progress-container {
            width: 100%;
            height: 20px;
            background-color: #f0f0f0;
            border-radius: 10px;
            overflow: hidden;
            margin: 20px 0;
        }
        
        .progress-bar {
            height: 100%;
            background-color: #0176D3;
            transition: width 0.3s ease;
            border-radius: 10px;
            background-image: linear-gradient(
                45deg,
                rgba(255,255,255,.15) 25%,
                transparent 25%,
                transparent 50%,
                rgba(255,255,255,.15) 50%,
                rgba(255,255,255,.15) 75%,
                transparent 75%,
                transparent
            );
            background-size: 40px 40px;
            animation: progress-bar-stripes 1s linear infinite;
        }
        
        @keyframes progress-bar-stripes {
            from {
                background-position: 40px 0;
            }
            to {
                background-position: 0 0;
            }
        }
        
        .progress-message {
            text-align: center;
            margin-top: 10px;
            color: #666;
            font-size: 14px;
        }
        
        /* Modal variants */
        .modal-success .modal-header {
            background-color: #2E844A;
            color: white;
        }
        
        .modal-error .modal-header {
            background-color: #dc3545;
            color: white;
        }
        
        .modal-warning .modal-header {
            background-color: #FFB75D;
            color: #333;
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="header-content">
            <h1>
                <i class="fas fa-sitemap"></i>
                Product Hierarchy Visualization
            </h1>
            <div class="header-actions">
                <div class="toolbar-right" style="display: flex; align-items: center; gap: 10px;">
                    <button class="btn btn-primary" onclick="syncProductHierarchy()" title="Sync product hierarchy data with Salesforce">
                        <i class="fas fa-sync-alt"></i>
                        Sync with Salesforce
                    </button>
                </div>
                <div class="org-selector-wrapper">
                    <label for="org-selector" class="field-label">Org:</label>
                    <div id="org-selector-container" style="min-width: 250px;"></div>
                </div>
                <button class="btn btn-secondary" onclick="window.location.href='/'">
                    <i class="fas fa-arrow-left"></i>
                    Back to Home
                </button>
            </div>
        </div>
    </div>

    <div class="breadcrumb">
        <a href="/" class="breadcrumb-item">Home</a>
        <span class="breadcrumb-separator">/</span>
        <a href="/data-management" class="breadcrumb-item">Data Management</a>
        <span class="breadcrumb-separator">/</span>
        <span class="breadcrumb-current">Product Hierarchy</span>
    </div>

    <div class="main-container">
        <div class="visualization-panel">
            <div class="visualization-header">
                <h2 style="font-size: 1.125rem; font-weight: 600;">Hierarchy View</h2>
                <div class="filter-controls" style="display: flex; align-items: center; gap: 15px; margin-right: 15px;">
                    <label style="display: flex; align-items: center; gap: 5px; font-size: 0.875rem;">
                        Show:
                        <select id="activeFilter" class="filter-select" onchange="applyFilters()" style="padding: 4px 8px; border: 1px solid #DDDBDA; border-radius: 4px; font-size: 0.875rem;">
                            <option value="all">All Items</option>
                            <option value="active">Active Only</option>
                            <option value="inactive">Inactive Only</option>
                        </select>
                    </label>
                    <label style="display: flex; align-items: center; gap: 5px; font-size: 0.875rem;">
                        <input type="checkbox" id="syncedOnlyFilter" onchange="applyFilters()">
                        Synced Only
                    </label>
                </div>
                <div class="visualization-controls">
                    <button class="control-btn" onclick="refreshHierarchy()" title="Refresh Data" style="background-color: #0176D3; color: white;">
                        <i class="fas fa-sync-alt"></i>
                    </button>
                    <button class="control-btn" onclick="fitView()" title="Fit to View">
                        <i class="fas fa-compress"></i>
                    </button>
                    <button class="control-btn" onclick="toggleFullscreen()" title="Fullscreen">
                        <i class="fas fa-expand"></i>
                    </button>
                    <button class="control-btn" onclick="exportImage()" title="Export as Image">
                        <i class="fas fa-download"></i>
                    </button>
                </div>
            </div>
            <div id="hierarchy-container">
                <div class="loading-overlay" id="loading">
                    <div class="loading-spinner"></div>
                </div>
                <div class="empty-state" id="empty-state" style="display: none;">
                    <i class="fas fa-inbox"></i>
                    <p>No hierarchy data available</p>
                    <button class="btn btn-primary" onclick="loadSampleData()">
                        Load Sample Data
                    </button>
                </div>
            </div>
            <div class="toolbar" id="main-toolbar">
                <button class="toolbar-btn" onclick="zoomIn()" title="Zoom In">
                    <i class="fas fa-search-plus"></i>
                </button>
                <button class="toolbar-btn" onclick="zoomOut()" title="Zoom Out">
                    <i class="fas fa-search-minus"></i>
                </button>
                <button class="toolbar-btn" onclick="resetView()" title="Reset View">
                    <i class="fas fa-home"></i>
                </button>
                <button class="toolbar-btn" id="layout-btn" onclick="fitToScreen()" title="Fit to Screen">
                    <i class="fas fa-compress"></i>
                </button>
            </div>
        </div>

        <div class="details-panel" id="details-panel">
            <div class="details-header">
                <h3 style="font-size: 1.125rem; font-weight: 600;">Details</h3>
                <button class="control-btn" onclick="toggleDetailsPanel()">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="details-content" id="details-content">
                <div class="empty-state" style="height: 200px;">
                    <i class="fas fa-mouse-pointer"></i>
                    <p style="font-size: 0.875rem;">Select an item to view details</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let currentLayout = 'vertical';
        let selectedNode = null;
        let originalData = null;
        let currentData = null;
        let d3Root = null;
        let d3Update = null;
        let root = null; // D3 hierarchy root for deletion functions
        window.hierarchyData = { nodes: [] }; // For inline editor


        // Helper Functions
        function generateSampleData() {
            return {
                id: 'catalog-1',
                name: 'Revenue Cloud Products',
                type: 'catalog',
                children: [
                    {
                        id: 'cat-1',
                        name: 'Software Licenses',
                        type: 'category',
                        children: [
                            {
                                id: 'subcat-1',
                                name: 'Enterprise',
                                type: 'subcategory',
                                children: [
                                    {
                                        id: 'subcat-1-1',
                                        name: 'Core Products',
                                        type: 'subcategory',
                                        children: [
                                            {
                                                id: 'prod-1',
                                                name: 'Revenue Cloud Enterprise',
                                                type: 'product',
                                                price: '$5,000/month',
                                                children: [
                                                    {
                                                        id: 'var-1',
                                                        name: '100 Users',
                                                        type: 'variant',
                                                        price: '$5,000/month'
                                                    },
                                                    {
                                                        id: 'var-2',
                                                        name: '500 Users',
                                                        type: 'variant',
                                                        price: '$20,000/month'
                                                    }
                                                ]
                                            },
                                            {
                                                id: 'prod-2',
                                                name: 'CPQ Enterprise',
                                                type: 'product',
                                                price: '$3,000/month'
                                            }
                                        ]
                                    },
                                    {
                                        id: 'subcat-1-2',
                                        name: 'Add-on Products',
                                        type: 'subcategory',
                                        children: [
                                            {
                                                id: 'prod-6',
                                                name: 'Advanced Analytics',
                                                type: 'product',
                                                price: '$1,000/month'
                                            },
                                            {
                                                id: 'prod-7',
                                                name: 'AI Pricing Optimizer',
                                                type: 'product',
                                                price: '$2,000/month'
                                            }
                                        ]
                                    }
                                ]
                            },
                            {
                                id: 'subcat-2',
                                name: 'Professional',
                                type: 'subcategory',
                                children: [
                                    {
                                        id: 'prod-3',
                                        name: 'Revenue Cloud Professional',
                                        type: 'product',
                                        price: '$1,500/month'
                                    }
                                ]
                            }
                        ]
                    },
                    {
                        id: 'cat-2',
                        name: 'Services',
                        type: 'category',
                        children: [
                            {
                                id: 'subcat-3',
                                name: 'Implementation',
                                type: 'subcategory',
                                children: [
                                    {
                                        id: 'subcat-3-1',
                                        name: 'Standard Services',
                                        type: 'subcategory',
                                        children: [
                                            {
                                                id: 'prod-4',
                                                name: 'Standard Implementation',
                                                type: 'product',
                                                price: '$50,000'
                                            },
                                            {
                                                id: 'prod-8',
                                                name: 'Data Migration Service',
                                                type: 'product',
                                                price: '$25,000'
                                            }
                                        ]
                                    },
                                    {
                                        id: 'subcat-3-2',
                                        name: 'Premium Services',
                                        type: 'subcategory',
                                        children: [
                                            {
                                                id: 'prod-5',
                                                name: 'Enterprise Implementation',
                                                type: 'product',
                                                price: '$150,000'
                                            },
                                            {
                                                id: 'prod-9',
                                                name: 'Custom Integration Package',
                                                type: 'product',
                                                price: '$75,000'
                                            }
                                        ]
                                    }
                                ]
                            }
                        ]
                    }
                ]
            };
        }

        function showNodeDetails(node) {
            console.log('showNodeDetails called with:', node);
            const detailsContent = document.getElementById('details-content');
            
            if (!node) {
                console.error('No node data provided');
                return;
            }
            
            let detailsHTML = `
                <div class="details-section">
                    <div class="section-title">Basic Information</div>
                    <div class="detail-item">
                        <span class="detail-label">Name</span>
                        <span class="detail-value" data-field="name">${node.name || 'Unknown'}</span>
                    </div>
                    <div class="detail-item">
                        <span class="detail-label">Type</span>
                        <span class="detail-value" data-field="type">${(node.type || 'unknown').charAt(0).toUpperCase() + (node.type || 'unknown').slice(1)}</span>
                    </div>
                    <div class="detail-item">
                        <span class="detail-label">ID</span>
                        <span class="detail-value">${node.id || 'N/A'}</span>
                    </div>
                    ${node.productCode !== undefined ? `
                        <div class="detail-item">
                            <span class="detail-label">Product Code</span>
                            <span class="detail-value" data-field="productCode">${node.productCode || ''}</span>
                        </div>
                    ` : ''}
                    ${node.price !== undefined ? `
                        <div class="detail-item">
                            <span class="detail-label">Price</span>
                            <span class="detail-value" data-field="price">${node.price || ''}</span>
                        </div>
                    ` : ''}
                    ${node.isActive !== undefined ? `
                        <div class="detail-item">
                            <span class="detail-label">Status</span>
                            <span class="detail-value" data-field="isActive">${node.isActive ? 'Active' : 'Inactive'}</span>
                        </div>
                    ` : ''}
                    ${node.isBundle ? `
                        <div class="detail-item">
                            <span class="detail-label">Type</span>
                            <span class="detail-value">Bundle Product</span>
                        </div>
                    ` : ''}
                    ${node.quantity !== undefined ? `
                        <div class="detail-item">
                            <span class="detail-label">Quantity</span>
                            <span class="detail-value" data-field="quantity">${node.quantity || ''}</span>
                        </div>
                    ` : ''}
                    ${node.isRequired !== undefined ? `
                        <div class="detail-item">
                            <span class="detail-label">Required</span>
                            <span class="detail-value" data-field="isRequired">${node.isRequired ? 'Yes' : 'No'}</span>
                        </div>
                    ` : ''}
                </div>
            `;

            if (node.stats) {
                detailsHTML += `
                    <div class="details-section">
                        <div class="section-title">Statistics</div>
                        ${node.stats.children !== undefined ? `
                            <div class="detail-item">
                                <span class="detail-label">Direct Children</span>
                                <span class="detail-value">${node.stats.children}</span>
                            </div>
                        ` : ''}
                        ${node.stats.products !== undefined ? `
                            <div class="detail-item">
                                <span class="detail-label">Total Products</span>
                                <span class="detail-value">${node.stats.products}</span>
                            </div>
                        ` : ''}
                        ${node.stats.catalogs !== undefined ? `
                            <div class="detail-item">
                                <span class="detail-label">Total Catalogs</span>
                                <span class="detail-value">${node.stats.catalogs}</span>
                            </div>
                        ` : ''}
                        ${node.stats.categories !== undefined ? `
                            <div class="detail-item">
                                <span class="detail-label">Total Categories</span>
                                <span class="detail-value">${node.stats.categories}</span>
                            </div>
                        ` : ''}
                    </div>
                `;
            }
            
            // Count children if available
            if (node.children && node.children.length > 0) {
                detailsHTML += `
                    <div class="details-section">
                        <div class="section-title">Hierarchy Info</div>
                        <div class="detail-item">
                            <span class="detail-label">Direct Children</span>
                            <span class="detail-value">${node.children.length}</span>
                        </div>
                    </div>
                `;
            }

            detailsHTML += `
                <div class="details-section">
                    <div class="section-title">Actions</div>
                    <button class="btn btn-primary" style="width: 100%; margin-bottom: 0.5rem;" onclick="editNode('${node.id}')">
                        <i class="fas fa-edit"></i>
                        Edit Details
                    </button>
                    <button class="btn btn-secondary" style="width: 100%;" onclick="viewInDataManagement('${node.type}', '${node.id}')">
                        <i class="fas fa-external-link-alt"></i>
                        View in Data Management
                    </button>
                </div>
            `;

            detailsContent.innerHTML = detailsHTML;
        }

        // Modal functions
        function showModal(title, content, type = 'info', buttons = null, onShow = null) {
            console.log('=== SHOW MODAL CALLED ===');
            console.log('showModal called with:', { title, content, type, buttons });
            console.log('Content type:', typeof content);
            console.log('Content length:', content ? content.length : 0);
            
            const existingModal = document.querySelector('.modal-overlay');
            if (existingModal) {
                console.log('Removing existing modal');
                existingModal.remove();
            }
            
            const modal = document.createElement('div');
            modal.className = 'modal-overlay active';
            
            const modalClass = type === 'error' ? 'modal-error' : 
                             type === 'warning' ? 'modal-warning' : 
                             type === 'success' ? 'modal-success' : '';
            
            const defaultButtons = buttons || [
                {
                    text: 'OK',
                    className: 'btn-primary',
                    onClick: () => closeModal()
                }
            ];
            
            const buttonsHtml = defaultButtons.map((btn, index) => 
                `<button class="btn ${btn.className}" data-button-index="${index}">${btn.text}</button>`
            ).join('');
            
            modal.innerHTML = `
                <div class="modal-content ${modalClass}">
                    <div class="modal-header">
                        <h2>${title}</h2>
                        <button class="close-button" onclick="closeModal()">
                            <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
                                <path d="M12 4L4 12" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                                <path d="M4 4L12 12" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                            </svg>
                        </button>
                    </div>
                    <div class="modal-body">
                        ${typeof content === 'string' ? content : ''}
                    </div>
                    <div class="modal-footer">
                        ${buttonsHtml}
                    </div>
                </div>
            `;
            
            console.log('Appending modal to body');
            document.body.appendChild(modal);
            console.log('Modal appended, checking if visible...');
            console.log('Modal element:', modal);
            console.log('Modal display style:', window.getComputedStyle(modal).display);
            
            // Attach click handlers to buttons
            modal.querySelectorAll('button[data-button-index]').forEach(button => {
                const index = parseInt(button.getAttribute('data-button-index'));
                button.addEventListener('click', defaultButtons[index].onClick);
            });
            
            // Call onShow callback if provided
            if (onShow) {
                setTimeout(onShow, 10);
            }
        }
        
        function closeModal() {
            const modal = document.querySelector('.modal-overlay');
            if (modal) {
                modal.remove();
            }
        }
        
        // Control Functions (these will be reimplemented for D3)
        function fitView() {
            // TODO: Implement for D3
        }

        function zoomIn() {
            // TODO: Implement for D3
        }

        function zoomOut() {
            // TODO: Implement for D3
        }

        function resetView() {
            // TODO: Implement for D3
        }

        function toggleLayout() {
            currentLayout = currentLayout === 'vertical' ? 'horizontal' : 'vertical';
            refreshHierarchy();
        }

        function toggleFullscreen() {
            const container = document.querySelector('.visualization-panel');
            if (!document.fullscreenElement) {
                container.requestFullscreen();
            } else {
                document.exitFullscreen();
            }
        }

        function exportImage() {
            // Implement image export functionality
            alert('Export functionality coming soon!');
        }

        function toggleDetailsPanel() {
            const panel = document.getElementById('details-panel');
            panel.classList.toggle('collapsed');
        }

        function refreshHierarchy() {
            document.getElementById('loading').style.display = 'flex';
            // Re-render the component
            renderApp();
        }

        function loadSampleData() {
            document.getElementById('empty-state').style.display = 'none';
            document.getElementById('loading').style.display = 'none';
            const container = document.getElementById('hierarchy-container');
            container.innerHTML = '';
            
            // Use sample data
            const sampleData = generateSampleData();
            originalData = sampleData;
            currentData = JSON.parse(JSON.stringify(originalData));
            renderD3Tree(currentData);
        }

        function editNode(nodeId) {
            // Implement edit functionality
            alert(`Edit functionality for ${nodeId} coming soon!`);
        }

        function viewInDataManagement(type, id) {
            // Navigate to data management with pre-selected object
            window.location.href = `/data-management?type=${type}&id=${id}`;
        }

        
        // Filter functions
        function applyFilters() {
            if (!originalData) return;
            
            const activeFilter = document.getElementById('activeFilter').value;
            const syncedOnly = document.getElementById('syncedOnlyFilter').checked;
            
            // Save filter preferences to sessionStorage
            sessionStorage.setItem('hierarchy-activeFilter', activeFilter);
            sessionStorage.setItem('hierarchy-syncedOnly', syncedOnly);
            
            // Deep clone the original data
            currentData = JSON.parse(JSON.stringify(originalData));
            
            // Clear any previous filter flags
            function clearFilterFlags(node) {
                if (node.shownForChildren) {
                    delete node.shownForChildren;
                }
                if (node.children) {
                    node.children.forEach(clearFilterFlags);
                }
            }
            clearFilterFlags(currentData);
            
            // Apply filters recursively
            filterNode(currentData);
            
            // Re-render the tree
            const container = document.getElementById('hierarchy-container');
            container.innerHTML = '';
            renderD3Tree(currentData);
            
            // Store the hierarchy data globally for other functions to access
            window.hierarchyData = currentData;
            
            function filterNode(node) {
                if (!node) return true;
                
                // First, recursively filter children to determine if any are visible
                let hasVisibleChildren = false;
                if (node.children) {
                    const originalChildren = [...node.children];
                    node.children = node.children.filter(child => filterNode(child));
                    hasVisibleChildren = node.children.length > 0;
                }
                
                // Now check if this node should be visible based on filters
                let nodeMatchesFilter = true;
                
                // Active/Inactive filter (only for nodes with isActive property)
                if (activeFilter !== 'all' && node.isActive !== undefined) {
                    // Check for pending changes to isActive field
                    let effectiveIsActive = node.isActive;
                    if (window.changeTracker && node.id) {
                        const nodeChanges = window.changeTracker.pendingChanges.get(node.id);
                        if (nodeChanges && nodeChanges.has('isActive')) {
                            const change = nodeChanges.get('isActive');
                            effectiveIsActive = change.newValue;
                        }
                    }
                    
                    if (activeFilter === 'active' && !effectiveIsActive) {
                        nodeMatchesFilter = false;
                    } else if (activeFilter === 'inactive' && effectiveIsActive) {
                        nodeMatchesFilter = false;
                    }
                }
                
                // Synced filter
                if (nodeMatchesFilter && syncedOnly) {
                    // Check isSynced flag if available, otherwise check ID format
                    if (node.isSynced !== undefined) {
                        if (!node.isSynced) {
                            nodeMatchesFilter = false;
                        }
                    } else if (node.id) {
                        // Fallback: check if ID looks like a Salesforce ID
                        if (!node.id.startsWith('0') && !node.id.startsWith('a')) {
                            nodeMatchesFilter = false;
                        }
                    }
                }
                
                // Determine final visibility
                if (nodeMatchesFilter) {
                    // Node matches filter criteria - show it normally
                    return true;
                } else if (hasVisibleChildren) {
                    // Node doesn't match but has visible children - show it dimmed
                    node.shownForChildren = true;
                    return true;
                } else {
                    // Node doesn't match and has no visible children - hide it
                    return false;
                }
            }
        }
        
        // D3.js tree visualization with column-based layout
        function renderD3Tree(data) {
            // Make renderD3Tree globally accessible
            window.renderD3Tree = renderD3Tree;
            
            const container = document.getElementById('hierarchy-container');
            const width = container.clientWidth;
            const height = container.clientHeight;
            
            const svg = d3.select(container)
                .append('svg')
                .attr('width', width)
                .attr('height', height);
            
            const g = svg.append('g')
                .attr('transform', 'translate(100, 50)');  // Increased left margin from 50 to 100
            
            // Create separate groups for links and nodes
            const linksGroup = g.append('g').attr('class', 'links');
            const nodesGroup = g.append('g').attr('class', 'nodes');
            
            // Layout configuration
            const columnWidth = 250;  // Fixed width between columns
            const nodeHeight = 60;    // Vertical space per node
            const nodeWidth = 200;    // Increased width for better text display
            const nodePadding = 12;   // Padding inside nodes
            
            // Define zoom behavior early to avoid initialization errors
            const zoom = d3.zoom()
                .scaleExtent([0.5, 2])
                .on('zoom', (event) => {
                    const transform = event.transform;
                    g.attr('transform', transform);
                    // Update column headers positions
                    updateColumnHeaderPositions(transform);
                });
            
            root = d3.hierarchy(data);
            
            // CRITICAL REQUIREMENT: Always load with hierarchy collapsed
            // Only the root level should be visible on initial load
            // Users must manually expand nodes to see their children
            root.descendants().forEach(d => {
                if (d.children && d.children.length > 0) {
                    // Collapse ALL nodes except the root (depth 0)
                    if (d.depth > 0) {  // This will collapse catalogs and everything below
                        d._children = d.children;
                        d.children = null;
                    }
                }
            });
            
            // Function to prevent overlaps in node positioning
            function preventOverlaps(nodes) {
                // Group nodes by column (X position)
                const nodesByColumn = {};
                nodes.forEach(node => {
                    if (!nodesByColumn[node.x]) {
                        nodesByColumn[node.x] = [];
                    }
                    nodesByColumn[node.x].push(node);
                });
                
                // For each column, ensure no overlaps
                Object.keys(nodesByColumn).forEach(x => {
                    const columnNodes = nodesByColumn[x];
                    // Sort by current Y position
                    columnNodes.sort((a, b) => a.y - b.y);
                    
                    // Adjust positions to prevent overlaps
                    let lastY = null;
                    let lastHeight = 0;
                    columnNodes.forEach((node, i) => {
                        const currentHeight = node.data._height || nodeHeight;
                        if (i === 0) {
                            lastY = node.y;
                            lastHeight = currentHeight;
                        } else {
                            const minY = lastY + (lastHeight / 2) + (currentHeight / 2) + 15; // Dynamic spacing based on node heights
                            if (node.y < minY && !node._manualY) {
                                node.y = minY;
                            }
                            lastY = node.y;
                            lastHeight = currentHeight;
                        }
                    });
                });
            }
            
            // Function to calculate custom layout
            function calculateLayout(root) {
                // Clear any positioned flags to ensure fresh calculation
                root.descendants().forEach(node => {
                    delete node._positioned;
                });
                
                const levels = [];
                const nodesByDepth = {};
                
                // Group nodes by depth
                root.descendants().forEach(d => {
                    if (!nodesByDepth[d.depth]) {
                        nodesByDepth[d.depth] = [];
                    }
                    nodesByDepth[d.depth].push(d);
                });
                
                // Calculate positions for each level
                Object.keys(nodesByDepth).forEach(depth => {
                    const nodesAtDepth = nodesByDepth[depth];
                    const depthNum = parseInt(depth);
                    
                    // Special handling for nodes to position them in correct columns
                    // based on their type and category hierarchy depth
                    const products = nodesAtDepth.filter(n => n.data.type === 'product');
                    const categories = nodesAtDepth.filter(n => n.data.type === 'category' || n.data.type === 'subcategory');
                    const components = nodesAtDepth.filter(n => n.data.type === 'component');
                    
                    // Handle products specially
                    if (products.length > 0) {
                        // Get all visible products
                        const visibleProducts = products.filter(n => n.parent && n.parent.children);
                        console.log(`Handling ${visibleProducts.length} products at depth ${depth}`);
                        
                        if (visibleProducts.length > 0) {
                            // Group products by their parent node
                            const productsByParent = {};
                            visibleProducts.forEach(product => {
                                const parentId = product.parent.data.id || product.parent.data.name;
                                if (!productsByParent[parentId]) {
                                    productsByParent[parentId] = {
                                        parent: product.parent,
                                        products: []
                                    };
                                }
                                productsByParent[parentId].products.push(product);
                            });
                            
                            // Position each group of products
                            Object.values(productsByParent).forEach(group => {
                                const parent = group.parent;
                                const groupProducts = group.products;
                                
                                // Sort products within the group
                                groupProducts.sort((a, b) => {
                                    const aName = a.data.name || '';
                                    const bName = b.data.name || '';
                                    return aName.localeCompare(bName);
                                });
                                
                                // Determine the column based on category depth
                                let categoryDepth = 0;
                                let current = parent;
                                while (current && (current.data.type === 'category' || current.data.type === 'subcategory')) {
                                    categoryDepth++;
                                    current = current.parent;
                                }
                                
                                // Calculate Y position centered around parent
                                const parentY = parent.y;
                                const spacing = 15; // Spacing between nodes
                                const groupHeight = groupProducts.length * (nodeHeight + spacing) - spacing;
                                const startY = parentY - (groupHeight / 2) + (nodeHeight / 2);
                                
                                // Sort products: bundle products first, then non-bundle products
                                groupProducts.sort((a, b) => {
                                    const aHasChildren = (a.children && a.children.length > 0) || (a._children && a._children.length > 0);
                                    const bHasChildren = (b.children && b.children.length > 0) || (b._children && b._children.length > 0);
                                    
                                    // Bundle products (with children) come first
                                    if (aHasChildren && !bHasChildren) return -1;
                                    if (!aHasChildren && bHasChildren) return 1;
                                    
                                    // If both are the same type, maintain their original order
                                    return 0;
                                });
                                
                                // Position products in this group
                                groupProducts.forEach((node, index) => {
                                    // Place products after all category levels
                                    node.x = (1 + categoryDepth + 1) * columnWidth;
                                    node._positioned = true; // Mark as positioned
                                    if (!node._manualY) {
                                        node.y = startY + (index * (nodeHeight + spacing));
                                    }
                                });
                            });
                        }
                    }
                    
                    // Handle categories and subcategories
                    if (categories.length > 0) {
                        categories.forEach(node => {
                            if (node.parent) {
                                // Count category depth from catalog
                                let categoryLevel = 0;
                                let current = node;
                                while (current.parent && (current.parent.data.type === 'category' || current.parent.data.type === 'subcategory')) {
                                    categoryLevel++;
                                    current = current.parent;
                                }
                                
                                // Position in appropriate column
                                // catalog=1, category=2, subcategory1=3, subcategory2=4, etc.
                                node.x = (2 + categoryLevel) * columnWidth;
                                if (!node._manualY) {
                                    node.y = node.parent.y;
                                }
                            }
                        });
                    }
                    
                    // Handle components
                    if (components.length > 0) {
                        // Get all visible components
                        const visibleComponents = nodesAtDepth.filter(n => n.data.type === 'component' && n.parent && n.parent.children);
                        
                        if (visibleComponents.length > 0) {
                            // Group components by their parent product
                            const componentsByProduct = {};
                            visibleComponents.forEach(comp => {
                                const productId = comp.parent.data.id;
                                if (!componentsByProduct[productId]) {
                                    componentsByProduct[productId] = [];
                                }
                                componentsByProduct[productId].push(comp);
                            });
                            
                            // Sort products by Y position
                            const sortedProducts = Object.keys(componentsByProduct).sort((a, b) => {
                                const prodA = visibleComponents.find(c => c.parent.data.id === a).parent;
                                const prodB = visibleComponents.find(c => c.parent.data.id === b).parent;
                                return prodA.y - prodB.y;
                            });
                            
                            let currentY = 50; // Start from top with some padding
                            
                            sortedProducts.forEach(productId => {
                                const components = componentsByProduct[productId];
                                // Sort components by sequence if available
                                components.sort((a, b) => (a.data.sequence || 0) - (b.data.sequence || 0));
                                
                                components.forEach((node, index) => {
                                    // Check if this is actually a component (not a regular product)
                                    if (node.data.type === 'component') {
                                        // Determine the column based on parent product's category depth
                                        let categoryDepth = 0;
                                        let current = node.parent ? node.parent.parent : null;
                                        while (current && (current.data.type === 'category' || current.data.type === 'subcategory')) {
                                            categoryDepth++;
                                            current = current.parent;
                                        }
                                        
                                        // Place components in the bundle components column
                                        // catalog=1, categories..., product=N, component=N+1
                                        node.x = (1 + categoryDepth + 2) * columnWidth;
                                        node._positioned = true; // Mark as positioned
                                        
                                        // Set Y position for components
                                        if (!node._manualY) {
                                            node.y = currentY + (index * (nodeHeight + 15)); // Add 15px spacing
                                        }
                                    } else {
                                        // This is a regular product, position it normally
                                        let categoryDepth = 0;
                                        let current = node.parent;
                                        while (current && (current.data.type === 'category' || current.data.type === 'subcategory')) {
                                            categoryDepth++;
                                            current = current.parent;
                                        }
                                        node.x = (1 + categoryDepth + 1) * columnWidth;
                                        node._positioned = true; // Mark as positioned
                                        
                                        // Set Y position for products
                                        if (!node._manualY) {
                                            node.y = currentY + (index * (nodeHeight + 15)); // Add 15px spacing
                                        }
                                    }
                                });
                                
                                currentY += components.length * (nodeHeight + 15) + 20; // Add spacing between product groups
                            });
                            
                            return; // Skip normal processing for this depth
                        }
                    }
                    
                    // Normal processing for other depths
                    // Group nodes by parent to handle alignment
                    const nodesByParent = {};
                    nodesAtDepth.forEach(node => {
                        // Skip nodes that have already been positioned
                        if (node._positioned || node.data.type === 'product' || node.data.type === 'component') {
                            return;
                        }
                        const parentId = node.parent ? node.parent.data.id : 'root';
                        if (!nodesByParent[parentId]) {
                            nodesByParent[parentId] = [];
                        }
                        nodesByParent[parentId].push(node);
                    });
                    
                    // Position nodes based on their parent's position
                    Object.entries(nodesByParent).forEach(([parentId, siblings]) => {
                        let centerY;
                        
                        if (parentId === 'root') {
                            // Root level - center vertically
                            const totalHeight = siblings.length * nodeHeight;
                            centerY = height / 2;
                        } else {
                            // Find parent node and use its Y position as center
                            const parent = siblings[0].parent;
                            centerY = parent.y;
                        }
                        
                        // Sort siblings if they are products: bundle products first
                        if (siblings.length > 0 && siblings[0].data.type === 'product') {
                            siblings.sort((a, b) => {
                                const aHasChildren = (a.children && a.children.length > 0) || (a._children && a._children.length > 0);
                                const bHasChildren = (b.children && b.children.length > 0) || (b._children && b._children.length > 0);
                                
                                // Bundle products (with children) come first
                                if (aHasChildren && !bHasChildren) return -1;
                                if (!aHasChildren && bHasChildren) return 1;
                                
                                // If both are the same type, maintain their original order
                                return 0;
                            });
                        }
                        
                        // Calculate starting Y position to center siblings around parent
                        const spacing = 15; // Spacing between nodes
                        const totalHeight = siblings.length * (nodeHeight + spacing) - spacing;
                        const startY = centerY - (totalHeight / 2) + (nodeHeight / 2);
                        
                        siblings.forEach((node, index) => {
                            // Determine the appropriate column based on node type and hierarchy
                            let nodeX = depthNum * columnWidth; // Default position
                            
                            if (node.data.type === 'catalog') {
                                nodeX = 1 * columnWidth;
                            } else if (node.data.type === 'category' || node.data.type === 'subcategory') {
                                // Count category depth from catalog
                                let categoryLevel = 0;
                                let current = node;
                                while (current.parent && (current.parent.data.type === 'category' || current.parent.data.type === 'subcategory')) {
                                    categoryLevel++;
                                    current = current.parent;
                                }
                                nodeX = (2 + categoryLevel) * columnWidth;
                            } else if (node.data.type === 'product') {
                                // This should not happen as products are handled specially above
                                // But if it does, position based on parent
                                let categoryDepth = 0;
                                let current = node.parent;
                                while (current && (current.data.type === 'category' || current.data.type === 'subcategory')) {
                                    categoryDepth++;
                                    current = current.parent;
                                }
                                nodeX = (1 + categoryDepth + 1) * columnWidth;
                            } else if (node.data.type === 'component') {
                                // Count category depth of parent product's parent
                                let categoryDepth = 0;
                                let current = node.parent ? node.parent.parent : null;
                                while (current && (current.data.type === 'category' || current.data.type === 'subcategory')) {
                                    categoryDepth++;
                                    current = current.parent;
                                }
                                nodeX = (1 + categoryDepth + 2) * columnWidth;
                            }
                            
                            // Always set X position
                            node.x = nodeX;
                            
                            // Only set Y position if it hasn't been manually set
                            if (!node._manualY) {
                                node.y = startY + (index * (nodeHeight + 15)); // Add 15px spacing
                            }
                        });
                    });
                });
            }
            
            // Function to get column info dynamically based on actual structure
            function getColumnInfo(column) {
                // Base columns that are always the same
                const baseColumns = {
                    0: { label: 'All Catalogs', color: '#014486' },
                    1: { label: 'Product Catalog', color: '#0176D3' }
                };
                
                if (baseColumns[column]) {
                    return baseColumns[column];
                }
                
                // Determine the maximum category depth
                let maxCategoryDepth = 0;
                root.descendants().forEach(d => {
                    if (d.data.type === 'category' || d.data.type === 'subcategory') {
                        let depth = 0;
                        let current = d;
                        while (current.parent && (current.parent.data.type === 'category' || current.parent.data.type === 'subcategory')) {
                            depth++;
                            current = current.parent;
                        }
                        maxCategoryDepth = Math.max(maxCategoryDepth, depth);
                    }
                });
                
                // Dynamically assign columns based on structure
                if (column >= 2 && column < 2 + maxCategoryDepth + 1) {
                    // Category columns
                    const categoryLevel = column - 2;
                    if (categoryLevel === 0) {
                        return { label: 'Category', color: '#00D4FF' };
                    } else if (categoryLevel === 1) {
                        return { label: 'Sub-Category', color: '#9050E9' };
                    } else {
                        return { label: `Sub-Category L${categoryLevel}`, color: '#6B46C1' };
                    }
                } else if (column === 2 + maxCategoryDepth + 1) {
                    // Product column
                    return { label: 'Product', color: '#2E844A' };
                } else if (column === 2 + maxCategoryDepth + 2) {
                    // Bundle Components column
                    return { label: 'Bundle Components', color: '#FF6900' };
                } else {
                    // Any additional columns
                    return { label: 'Product Variant', color: '#FFB75D' };
                }
            }
            
            // Define link colors based on depth
            const linkColors = [
                '#014486',   // Depth 0-1: Dark blue (root to catalog)
                '#0176D3',   // Depth 1-2: Blue (catalog to category)
                '#00D4FF',   // Depth 2-3: Light blue (category to product)
                '#9050E9',   // Depth 3-4: Purple (product to component/subcategory)
                '#FF6900',   // Depth 4-5: Orange (component relationships)
                '#FFB75D'    // Depth 5+: Light orange (deeper levels)
            ];
            
            // Function to add column headers
            function addColumnHeaders() {
                // Get unique depths with visible nodes based on their actual column positions
                const visibleColumns = new Set();
                let maxColumn = 0;
                
                root.descendants().forEach(d => {
                    // Use the actual x position to determine the column
                    const column = Math.round(d.x / columnWidth);
                    visibleColumns.add(column);
                    maxColumn = Math.max(maxColumn, column);
                });
                
                // Ensure all columns from 0 to maxColumn are included
                for (let i = 0; i <= maxColumn; i++) {
                    visibleColumns.add(i);
                }
                
                // Check if headers need updating
                const existingHeaders = d3.select(container).selectAll('.column-header-fixed');
                const existingColumns = new Set();
                existingHeaders.each(function() {
                    const column = parseInt(d3.select(this).attr('data-column'));
                    if (!isNaN(column)) existingColumns.add(column);
                });
                
                // Always remove and rebuild headers to ensure proper alignment
                d3.select(container).selectAll('.column-header-fixed').remove();
                
                // Get current transform of the g element
                const currentTransform = d3.zoomTransform(svg.node());
                const scale = currentTransform.k;
                const translateX = currentTransform.x;
                
                // Add headers for each visible column
                visibleColumns.forEach(column => {
                    const colInfo = getColumnInfo(column);
                    if (colInfo) {
                        // Create a fixed header div outside the SVG
                        // Position at center of column minus half the header width
                        const columnCenterX = 100 + (column * columnWidth * scale) + translateX;
                        const headerLeft = columnCenterX - (nodeWidth / 2);
                        
                        const headerDiv = d3.select(container)
                            .append('div')
                            .attr('class', 'column-header-fixed')
                            .style('position', 'absolute')
                            .style('top', '20px')
                            .style('left', `${headerLeft}px`)
                            .style('width', `${nodeWidth}px`)
                            .style('text-align', 'center')
                            .style('z-index', '10')
                            .attr('data-column', column);  // Store column for comparison
                        
                        // Add color bar
                        headerDiv.append('div')
                            .style('width', '100%')
                            .style('height', '4px')
                            .style('background-color', colInfo.color)
                            .style('border-radius', '2px')
                            .style('margin-bottom', '6px');
                        
                        // Add label
                        headerDiv.append('div')
                            .style('font-size', '0.875rem')
                            .style('font-weight', '600')
                            .style('color', 'var(--text-primary)')
                            .style('text-transform', 'uppercase')
                            .style('letter-spacing', '0.05em')
                            .text(colInfo.label);
                    }
                });
            }
            
            // Function to update the tree
            function update(source) {
                // Make update function globally accessible
                window.update = update;
                // Ensure permissions are loaded
                if (!window.userPermissions) {
                    console.log('Permissions not loaded yet, loading now...');
                    loadUserPermissions();
                }
                
                // Apply pending changes to node data before rendering
                if (window.changeTracker && window.changeTracker.pendingChanges.size > 0) {
                    root.descendants().forEach(node => {
                        const nodeId = node.data.id;
                        const nodeChanges = window.changeTracker.pendingChanges.get(nodeId);
                        if (nodeChanges && nodeChanges.size > 0) {
                            nodeChanges.forEach((change, fieldName) => {
                                // Apply the pending change to the node data
                                node.data[fieldName] = change.newValue;
                            });
                        }
                    });
                }
                
                // Get all nodes
                const nodes = root.descendants();
                const links = root.links();
                
                // Calculate custom layout
                calculateLayout(root);
                
                // Prevent overlaps after layout calculation
                preventOverlaps(nodes);
                
                // Don't add column headers here - they'll be added after transitions complete
                
                // Debug: Log node positions
                console.log('Node positions after layout:');
                root.descendants().forEach(d => {
                    if (d.data.type === 'product' || d.data.type === 'category') {
                        console.log(`${d.data.name} (${d.data.type}): x=${d.x}, depth=${d.depth}`);
                    }
                });
                
                // Auto-pan to show expanded content
                if (source && source.children && source.children.length > 0) {
                    // Find the rightmost visible node
                    let maxX = 0;
                    root.descendants().forEach(d => {
                        if (d.children) {  // Only consider visible nodes
                            let effectiveX = d.x;
                            maxX = Math.max(maxX, effectiveX);
                        }
                    });
                    
                    console.log('Max X position:', maxX);
                    console.log('Container width:', container.clientWidth);
                    
                    // Calculate required translation to fit content
                    const containerWidth = container.clientWidth;
                    const contentWidth = maxX + nodeWidth + 100; // Add some padding
                    
                    console.log('Content width:', contentWidth);
                    
                    if (contentWidth > containerWidth) {
                        // Pan left to show the expanded content
                        const currentTransform = d3.zoomTransform(svg.node());
                        const newX = Math.min(100, containerWidth - contentWidth);
                        
                        console.log('Panning to X:', newX);
                        
                        svg.transition()
                            .duration(500)
                            .call(zoom.transform, d3.zoomIdentity
                                .translate(newX, 50)
                                .scale(currentTransform.k));
                    }
                }
                
                // Update links
                const link = linksGroup.selectAll('.link')
                    .data(links, d => d.source.id + '-' + d.target.id);
                
                // Remove old links
                link.exit().remove();
                
                // Enter new links
                const linkEnter = link.enter().append('path')
                    .attr('class', 'link')
                    .attr('fill', 'none')
                    .attr('stroke', d => {
                        // Use source node's depth to determine color
                        const depth = d.source.depth;
                        return linkColors[Math.min(depth, linkColors.length - 1)];
                    })
                    .attr('stroke-width', 2)
                    .attr('opacity', 0.6);
                
                // Update all links
                link.merge(linkEnter)
                    .attr('stroke', d => {
                        // Ensure color is maintained on update
                        const depth = d.source.depth;
                        return linkColors[Math.min(depth, linkColors.length - 1)];
                    })
                    .transition()
                    .duration(500)
                    .attr('d', d => {
                        const sourceX = d.source.x + nodeWidth / 2;
                        const sourceY = d.source.y;
                        const targetX = d.target.x - nodeWidth / 2;
                        const targetY = d.target.y;
                        
                        // Create a smooth curve
                        return `M${sourceX},${sourceY}
                                C${sourceX + 50},${sourceY}
                                 ${targetX - 50},${targetY}
                                 ${targetX},${targetY}`;
                    });
                
                // Update nodes
                const node = nodesGroup.selectAll('.node')
                    .data(nodes, d => d.data.id);
                
                // Remove old nodes
                node.exit()
                    .transition()
                    .duration(500)
                    .style('opacity', 0)
                    .remove();
                
                // Enter new nodes
                const nodeEnter = node.enter().append('g')
                    .attr('class', d => 'node' + (d.data.shownForChildren ? ' node-shown-for-children' : ''))
                    .attr('data-node-id', d => d.data.id)
                    .attr('transform', d => `translate(${d.x},${d.y})`)
                    .style('opacity', 0);
                
                // Update all nodes
                node.merge(nodeEnter)
                    .attr('class', d => 'node' + (d.data.shownForChildren ? ' node-shown-for-children' : ''))
                    .transition()
                    .duration(500)
                    .style('opacity', d => {
                        // Reduced opacity for pending additions (temp IDs) and deletions
                        if (d.data.id && d.data.id.startsWith('temp_')) {
                            return 0.5;
                        }
                        // Check if marked for deletion
                        if (window.changeTracker && window.changeTracker.pendingChanges.has(d.data.id)) {
                            const changes = window.changeTracker.pendingChanges.get(d.data.id);
                            if (changes && changes.has('deletion')) {
                                return 0.5;
                            }
                        }
                        return 1;
                    })
                    .attr('transform', d => `translate(${d.x},${d.y})`)
                    .on('end', function() {
                        // Update column headers after all transitions complete
                        // Only do this once, on the first node's transition end
                        if (this === node.merge(nodeEnter).node()) {
                            addColumnHeaders();
                            const currentTransform = d3.zoomTransform(svg.node());
                            updateColumnHeaderPositions(currentTransform);
                        }
                    });
                
                // Update text content for existing nodes (to reflect pending changes)
                node.select('text')
                    .text(d => d.data.name);
                
                // Re-apply text wrapping and update rectangle height for updated nodes
                node.each(function(d) {
                    const nodeEl = d3.select(this);
                    const text = nodeEl.select('text');
                    const rect = nodeEl.select('rect');
                    
                    if (!text.empty()) {
                        // Calculate new height if needed
                        const textHeight = calculateTextHeight(d.data.name, nodeWidth - 40);
                        d.data._height = textHeight;
                        
                        // Update rectangle height and position
                        if (!rect.empty()) {
                            rect.attr('height', textHeight)
                                .attr('y', -textHeight / 2);
                        }
                        
                        // Wrap text
                        wrapText(text, nodeWidth - 40); // Leave space for expand button
                    }
                });
                
                // Add vertical-only drag behavior
                const drag = d3.drag()
                    .clickDistance(20) // Increase click distance threshold
                    .on('start', function(event, d) {
                        console.log('Drag started');
                        d3.select(this).raise().style('cursor', 'grabbing');
                        // Store the original x position to lock horizontal movement
                        d._fixedX = d.x;
                    })
                    .on('drag', function(event, d) {
                        // Only allow vertical movement
                        const proposedY = event.y;
                        
                        // Get all nodes in the same column
                        const nodesInSameColumn = nodes.filter(n => {
                            return n !== d && n.x === d.x;
                        });
                        
                        // Define minimum spacing between nodes
                        const draggedNodeHeight = d.data._height || nodeHeight;
                        const minSpacing = 15; // Just the gap, not including node heights
                        
                        // Check for collisions and find the constrained Y position
                        let constrainedY = proposedY;
                        
                        // Sort nodes in the same column by Y position
                        const sortedColumnNodes = nodesInSameColumn.sort((a, b) => a.y - b.y);
                        
                        // Find the closest nodes above and below
                        let nodeAbove = null;
                        let nodeBelow = null;
                        
                        for (const node of sortedColumnNodes) {
                            if (node.y < d.y && (!nodeAbove || node.y > nodeAbove.y)) {
                                nodeAbove = node;
                            }
                            if (node.y > d.y && (!nodeBelow || node.y < nodeBelow.y)) {
                                nodeBelow = node;
                            }
                        }
                        
                        // Constrain Y position to prevent overlap
                        if (nodeAbove) {
                            const aboveHeight = nodeAbove.data._height || nodeHeight;
                            const minY = nodeAbove.y + (aboveHeight / 2) + (draggedNodeHeight / 2) + minSpacing;
                            if (constrainedY < minY) {
                                constrainedY = minY;
                            }
                        }
                        if (nodeBelow) {
                            const belowHeight = nodeBelow.data._height || nodeHeight;
                            const maxY = nodeBelow.y - (belowHeight / 2) - (draggedNodeHeight / 2) - minSpacing;
                            if (constrainedY > maxY) {
                                constrainedY = maxY;
                            }
                        }
                        
                        // Calculate the actual movement
                        const deltaY = constrainedY - d.y;
                        
                        // Update the dragged node's position
                        d.y = constrainedY;
                        d._manualY = true;
                        d.x = d._fixedX; // Keep x position fixed
                        
                        // If this is a product being dragged, move all its expanded components
                        if (d.data.type === 'product' && d.children) {
                            d.children.forEach(child => {
                                if (child.data.type === 'component') {
                                    child.y += deltaY;
                                    child._manualY = true;
                                    // Update component visual position
                                    d3.select(`[data-node-id="${child.data.id}"]`)
                                        .transition()
                                        .duration(0)
                                        .attr('transform', `translate(${child.x},${child.y})`);
                                }
                            });
                        }
                        
                        // Update node position
                        d3.select(this)
                            .attr('transform', `translate(${d.x},${d.y})`);
                        
                        // Update all links in the visualization
                        linksGroup.selectAll('.link')
                            .attr('d', l => {
                                const sourceX = l.source.x + nodeWidth / 2;
                                const sourceY = l.source.y;
                                const targetX = l.target.x - nodeWidth / 2;
                                const targetY = l.target.y;
                                
                                return `M${sourceX},${sourceY}
                                        C${sourceX + 50},${sourceY}
                                         ${targetX - 50},${targetY}
                                         ${targetX},${targetY}`;
                            });
                    })
                    .on('end', function(event, d) {
                        d3.select(this).style('cursor', 'grab');
                    });
                
                // Apply drag to node groups (not the rect itself)
                nodeEnter.style('cursor', 'grab').call(drag);
                node.style('cursor', 'grab').call(drag);
                
                // For all nodes (enter + update), build their content
                nodesGroup.selectAll('.node').each(function(d) {
                    const node = d3.select(this);
                    
                    // Track if dragging
                    let isDragging = false;
                    
                    // Add pointerdown handler to track potential clicks
                    node.on('pointerdown.details', function(event, d) {
                        isDragging = false;
                        const startX = event.clientX;
                        const startY = event.clientY;
                        
                        const checkClick = function(e) {
                            const dx = e.clientX - startX;
                            const dy = e.clientY - startY;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            
                            if (distance > 5) {
                                isDragging = true;
                            }
                        };
                        
                        const handlePointerUp = function(e) {
                            const dx = e.clientX - startX;
                            const dy = e.clientY - startY;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            
                            if (!isDragging && distance < 5) {
                                console.log('Node clicked (pointer):', d.data.name);
                                event.stopPropagation();
                                
                                // Toggle selection if clicking the same node
                                if (selectedNode === d) {
                                    // Deselect the node
                                    selectedNode = null;
                                    nodesGroup.selectAll('.node').classed('selected', false);
                                    highlightPath(null); // This will restore depth-based colors
                                    // Clear details panel
                                    document.getElementById('details-content').innerHTML = '<p class="text-muted">Select a node to view details</p>';
                                } else {
                                    // Select the new node
                                    nodesGroup.selectAll('.node')
                                        .classed('selected', n => n === d);
                                    
                                    // Highlight path from root to selected node
                                    highlightPath(d);
                                    
                                    selectedNode = d;
                                    // Store globally for inline editor
                                    window.selectedNode = d;
                                    
                                    showNodeDetails(d.data || d);
                                    
                                    // Enable inline editing for the details panel
                                    if (window.inlineEditor) {
                                        setTimeout(() => {
                                            window.inlineEditor.enableEditMode();
                                        }, 100);
                                    }
                                }
                            }
                            
                            // Clean up
                            window.removeEventListener('pointermove', checkClick);
                            window.removeEventListener('pointerup', handlePointerUp);
                        };
                        
                        window.addEventListener('pointermove', checkClick);
                        window.addEventListener('pointerup', handlePointerUp);
                    });
                    
                    // For existing nodes, remove old expand/collapse circles and delete icons to rebuild them
                    node.selectAll('.expand-collapse-circle').remove();
                    node.selectAll('.delete-icon-group').remove();
                    
                    // Build content for new nodes
                    if (node.selectAll('rect').empty()) {
                        // Calculate required height based on text
                        const textHeight = calculateTextHeight(d.data.name, nodeWidth - 40);
                        d.data._height = textHeight; // Store height on the data
                        
                        // Add rectangle
                        const rect = node.append('rect')
                            .attr('width', nodeWidth)
                            .attr('height', textHeight)
                            .attr('x', -nodeWidth / 2)
                            .attr('y', -textHeight / 2)
                            .attr('rx', 6)
                            .attr('fill', d => {
                                // Lighter fill colors (15% opacity for better contrast with stroke)
                                const fillColors = {
                                    'root': 'rgba(1, 68, 134, 0.15)',      // Light version of #014486
                                    'catalog': 'rgba(1, 118, 211, 0.15)',  // Light version of #0176D3
                                    'category': 'rgba(0, 212, 255, 0.15)', // Light version of #00D4FF
                                    'subcategory': 'rgba(144, 80, 233, 0.15)',
                                    'product': 'rgba(46, 132, 74, 0.15)',  // Light version of #2E844A
                                    'component': 'rgba(255, 105, 0, 0.15)', // Light version of #FF6900
                                    'variant': 'rgba(255, 183, 93, 0.15)'
                                };
                                return fillColors[d.data.type] || 'rgba(81, 79, 77, 0.15)';
                            })
                            .style('stroke', d => {
                                // Original colors for outlines - using style instead of attr
                                const strokeColors = {
                                    'root': '#014486',      // Dark blue for root
                                    'catalog': '#0176D3',   // Primary blue for catalogs
                                    'category': '#00D4FF',  // Light blue for categories
                                    'subcategory': '#9050E9',
                                    'product': '#2E844A',   // Green for products
                                    'component': '#FF6900', // Orange for bundle components
                                    'variant': '#FFB75D'
                                };
                                return strokeColors[d.data.type] || '#514F4D';
                            })
                            .style('stroke-width', '1px')
                            .style('stroke-opacity', '1')
                            .style('stroke-linejoin', 'round')
                            .style('cursor', 'grab')
                            .on('mouseenter', function(event, d) {
                                // On hover, increase fill opacity
                                d3.select(this)
                                    .attr('fill', d => {
                                        // Darker fill colors (30% opacity on hover)
                                        const hoverFillColors = {
                                            'root': 'rgba(1, 68, 134, 0.3)',
                                            'catalog': 'rgba(1, 118, 211, 0.3)',
                                            'category': 'rgba(0, 212, 255, 0.3)',
                                            'subcategory': 'rgba(144, 80, 233, 0.3)',
                                            'product': 'rgba(46, 132, 74, 0.3)',
                                            'component': 'rgba(255, 105, 0, 0.3)',
                                            'variant': 'rgba(255, 183, 93, 0.3)'
                                        };
                                        return hoverFillColors[d.data.type] || 'rgba(81, 79, 77, 0.3)';
                                    });
                            })
                            .on('mouseleave', function(event, d) {
                                // On mouse leave, return to original fill
                                d3.select(this)
                                    .attr('fill', d => {
                                        const fillColors = {
                                            'root': 'rgba(1, 68, 134, 0.15)',
                                            'catalog': 'rgba(1, 118, 211, 0.15)',
                                            'category': 'rgba(0, 212, 255, 0.15)',
                                            'subcategory': 'rgba(144, 80, 233, 0.15)',
                                            'product': 'rgba(46, 132, 74, 0.15)',
                                            'component': 'rgba(255, 105, 0, 0.15)',
                                            'variant': 'rgba(255, 183, 93, 0.15)'
                                        };
                                        return fillColors[d.data.type] || 'rgba(81, 79, 77, 0.15)';
                                    });
                            })
                            .style('pointer-events', 'all');
                        
                        // Add text
                        const text = node.append('text')
                            .attr('text-anchor', 'start')
                            .attr('x', -nodeWidth / 2 + 10)  // 10px padding from left edge
                            .attr('y', 0)  // Center vertically
                            .attr('fill', d => {
                                // Use dark text color for better contrast on light backgrounds
                                return '#181818'; // var(--text-primary)
                            })
                            .style('font-weight', '600')
                            .style('font-size', '12px')
                            .style('pointer-events', 'none')
                            .style('user-select', 'none')
                            .text(d.data.name);
            
                        // Always wrap text to ensure proper formatting
                        wrapText(text, nodeWidth - 40); // Leave space for expand button
                    }
                    
                    // Add expand/collapse circle if node has children (rebuild for all nodes)
                    if (d._children || d.children) {
                            // Node is expanded if it has visible children
                            const isExpanded = d.children && d.children.length > 0;
                            
                            // Add circle background
                            // Position at the right end of the node
                            const xPosition = nodeWidth / 2 + 10;
                            const circleGroup = node.append('g')
                                .attr('transform', `translate(${xPosition}, 0)`)
                                .attr('class', 'expand-collapse-circle')
                                .style('cursor', 'pointer')
                                .style('pointer-events', 'all')
                                .on('mouseenter', function(event, d) {
                                    // Hover effect for circle
                                    d3.select(this).select('circle')
                                        .attr('fill', 'rgba(1, 118, 211, 0.1)')
                                        .attr('stroke', '#0176D3')
                                        .attr('stroke-width', 2);
                                })
                                .on('mouseleave', function(event, d) {
                                    // Return to normal state
                                    d3.select(this).select('circle')
                                        .attr('fill', '#fff')
                                        .attr('stroke', '#DDDBDA')
                                        .attr('stroke-width', 1.5);
                                })
                                .on('mousedown', function(event, d) {
                                    event.stopPropagation();
                                    event.preventDefault();
                                    // Toggle children on mousedown instead of click
                                    if (d.children) {
                                        d._children = d.children;
                                        d.children = null;
                                    } else {
                                        d.children = d._children;
                                        d._children = null;
                                    }
                                    // Reset manual Y positions when expanding/collapsing to allow proper layout
                                    root.descendants().forEach(node => {
                                        delete node._manualY;
                                    });
                                    update(d);
                                });
                            
                            // Circle background
                            const circle = circleGroup.append('circle')
                                .attr('r', 10)
                                .attr('fill', '#fff')
                                .attr('stroke', '#DDDBDA')
                                .attr('stroke-width', 1.5)
                                .style('transition', 'none')  // Instant hover effect
                                .style('pointer-events', 'all');  // Ensure circle captures events
                            
                            // Plus/minus icon
                            const iconSize = 6;
                            // Horizontal line (always visible)
                            circleGroup.append('line')
                                .attr('x1', -iconSize)
                                .attr('x2', iconSize)
                                .attr('y1', 0)
                                .attr('y2', 0)
                                .attr('stroke', '#514F4D')
                                .attr('stroke-width', 1.5)
                                .style('pointer-events', 'none');  // Don't capture mouse events
                            
                            // Vertical line (only for collapsed nodes - shows plus)
                            if (!isExpanded) {
                                circleGroup.append('line')
                                    .attr('class', 'vertical-line')
                                    .attr('x1', 0)
                                    .attr('x2', 0)
                                    .attr('y1', -iconSize)
                                    .attr('y2', iconSize)
                                    .attr('stroke', '#514F4D')
                                    .attr('stroke-width', 1.5)
                                    .style('pointer-events', 'none');  // Don't capture mouse events
                        }
                    }
                    
                    // Add delete icon for nodes where user has delete permission
                    // Only show on hover to avoid clutter
                    if (window.userPermissions && window.userPermissions.capabilities && window.userPermissions.capabilities.can_delete) {
                        const deleteGroup = node.append('g')
                            .attr('class', 'delete-icon-group')
                            .attr('transform', `translate(${-nodeWidth / 2 - 25}, 0)`) // Position to the left of the node
                            .style('opacity', 0) // Hidden by default
                            .style('cursor', 'pointer')
                            .style('pointer-events', 'all');
                        
                        // Delete icon background circle
                        deleteGroup.append('circle')
                            .attr('r', 12)
                            .attr('fill', '#fff')
                            .attr('stroke', '#dc3545')
                            .attr('stroke-width', 1.5);
                        
                        // Delete icon (trash can)
                        const iconGroup = deleteGroup.append('g')
                            .attr('transform', 'scale(0.8)'); // Scale down the icon
                        
                        // Trash can body
                        iconGroup.append('rect')
                            .attr('x', -5)
                            .attr('y', -3)
                            .attr('width', 10)
                            .attr('height', 12)
                            .attr('rx', 1)
                            .attr('fill', '#dc3545');
                        
                        // Trash can lid
                        iconGroup.append('rect')
                            .attr('x', -7)
                            .attr('y', -5)
                            .attr('width', 14)
                            .attr('height', 2)
                            .attr('fill', '#dc3545');
                        
                        // Trash can handle
                        iconGroup.append('rect')
                            .attr('x', -2)
                            .attr('y', -7)
                            .attr('width', 4)
                            .attr('height', 2)
                            .attr('rx', 1)
                            .attr('fill', '#dc3545');
                        
                        // Trash can lines
                        [-2, 0, 2].forEach(x => {
                            iconGroup.append('rect')
                                .attr('x', x - 0.5)
                                .attr('y', -1)
                                .attr('width', 1)
                                .attr('height', 7)
                                .attr('fill', '#fff');
                        });
                        
                        // Show/hide delete icon on node hover
                        node.on('mouseenter.delete', function(event, d) {
                            d3.select(this).select('.delete-icon-group')
                                .transition()
                                .duration(200)
                                .style('opacity', 1);
                        })
                        .on('mouseleave.delete', function(event, d) {
                            d3.select(this).select('.delete-icon-group')
                                .transition()
                                .duration(200)
                                .style('opacity', 0);
                        });
                        
                        // Delete icon hover effect
                        deleteGroup
                            .on('mouseenter', function(event, d) {
                                d3.select(this).select('circle')
                                    .attr('fill', 'rgba(220, 53, 69, 0.1)')
                                    .attr('stroke-width', 2);
                            })
                            .on('mouseleave', function(event, d) {
                                d3.select(this).select('circle')
                                    .attr('fill', '#fff')
                                    .attr('stroke-width', 1.5);
                            })
                            .on('pointerdown', function(event, d) {
                                event.stopPropagation();
                                event.stopImmediatePropagation();
                                event.preventDefault();
                                console.log('=== DELETE ICON CLICKED ===');
                                console.log('Delete icon clicked for node:', d.data.name, d.data);
                                console.log('Event type:', event.type);
                                console.log('User permissions:', window.userPermissions);
                                console.log('About to call initiateNodeDeletion...');
                                try {
                                    initiateNodeDeletion(d);
                                } catch (error) {
                                    console.error('ERROR calling initiateNodeDeletion:', error);
                                    console.error('Error stack:', error.stack);
                                }
                            })
                            .on('click', function(event, d) {
                                event.stopPropagation();
                                event.stopImmediatePropagation();
                                event.preventDefault();
                            });
                    }
                    
                    // Add add icon for nodes where user has create permission
                    // Only show on hover to avoid clutter
                    // Default to showing if permissions not loaded yet
                    const hasPermission = !window.userPermissions || !window.userPermissions.capabilities || 
                        window.userPermissions.capabilities.can_create || 
                        window.userPermissions.capabilities.can_edit_structure ||
                        window.userPermissions.capabilities.can_admin;
                    
                    if (hasPermission) {
                        console.log('Creating add icon - permissions:', window.userPermissions?.capabilities);
                        const addGroup = node.append('g')
                            .attr('class', 'add-icon-group')
                            .attr('transform', `translate(${-nodeWidth / 2 - 25}, -30)`) // Position above the delete icon
                            .style('opacity', 0) // Hidden by default
                            .style('cursor', 'pointer')
                            .style('pointer-events', 'all');
                        
                        // Add icon background circle
                        addGroup.append('circle')
                            .attr('r', 12)
                            .attr('fill', '#fff')
                            .attr('stroke', '#2E844A') // Success green color
                            .attr('stroke-width', 1.5);
                        
                        // Plus icon
                        const plusGroup = addGroup.append('g');
                        
                        // Horizontal line of plus
                        plusGroup.append('rect')
                            .attr('x', -6)
                            .attr('y', -1)
                            .attr('width', 12)
                            .attr('height', 2)
                            .attr('fill', '#2E844A');
                        
                        // Vertical line of plus
                        plusGroup.append('rect')
                            .attr('x', -1)
                            .attr('y', -6)
                            .attr('width', 2)
                            .attr('height', 12)
                            .attr('fill', '#2E844A');
                        
                        // Show/hide add icon on node hover
                        node.on('mouseenter.add', function(event, d) {
                            // Show add icon for all nodes for debugging
                            const nodeType = d.data.type;
                            console.log('Mouse enter node:', d.data.name, 'Type:', nodeType);
                            
                            // Always show the add icon for debugging
                            const addIcon = d3.select(this).select('.add-icon-group');
                            console.log('Showing add icon for:', d.data.name, 'Icon found:', !addIcon.empty());
                            if (!addIcon.empty()) {
                                addIcon
                                    .transition()
                                    .duration(200)
                                    .style('opacity', 1);
                            } else {
                                console.error('No add icon found for node:', d.data.name);
                            }
                        })
                        .on('mouseleave.add', function(event, d) {
                            d3.select(this).select('.add-icon-group')
                                .transition()
                                .duration(200)
                                .style('opacity', 0);
                        });
                        
                        // Add icon hover effect
                        addGroup
                            .on('mouseenter', function(event, d) {
                                d3.select(this).select('circle')
                                    .attr('fill', 'rgba(46, 132, 74, 0.1)')
                                    .attr('stroke-width', 2);
                            })
                            .on('mouseleave', function(event, d) {
                                d3.select(this).select('circle')
                                    .attr('fill', '#fff')
                                    .attr('stroke-width', 1.5);
                            })
                            .on('pointerdown', function(event, d) {
                                console.log('Add icon pointerdown event triggered');
                                event.stopPropagation();
                                event.stopImmediatePropagation();
                                event.preventDefault();
                                console.log('Add icon clicked for node:', d.data.name, d.data);
                                
                                // Call AddNodeManager to handle the add operation
                                if (!window.addNodeManager && typeof AddNodeManager !== 'undefined') {
                                    console.log('Creating AddNodeManager instance on demand');
                                    window.addNodeManager = new AddNodeManager();
                                }
                                
                                if (window.addNodeManager) {
                                    console.log('Calling addNodeManager.handleAddClick');
                                    window.addNodeManager.handleAddClick(d);
                                } else {
                                    console.error('AddNodeManager not available');
                                }
                            })
                            .on('click', function(event, d) {
                                event.stopPropagation();
                                event.stopImmediatePropagation();
                                event.preventDefault();
                            });
                    }
                    
                    // Update selected node styling
                    node.classed('selected', d => selectedNode === d);
                    
                    // Maintain highlighted path if a node is selected
                    if (selectedNode) {
                        highlightPath(selectedNode);
                    }
                    
                    // Update stroke for unsynced items
                    node.select('rect')
                        .attr('stroke-dasharray', d => {
                            // Dashed border for unsynced items
                            const isSynced = d.data.isSynced !== undefined ? d.data.isSynced : 
                                           (d.data.id && (d.data.id.startsWith('0') || d.data.id.startsWith('a')));
                            return !isSynced ? '4,2' : 'none';
                        });
                });
            
                // Function to calculate text height after wrapping
                function calculateTextHeight(textString, width) {
                    // Create a temporary text element to measure
                    const tempText = svg.append('text')
                        .style('visibility', 'hidden')
                        .text(textString);
                    
                    const words = textString.split(/\s+/).reverse();
                    let word;
                    let line = [];
                    let lineCount = 0;
                    const lineHeight = 14; // Line height in pixels
                    
                    const tspan = tempText.append('tspan');
                    
                    while (word = words.pop()) {
                        line.push(word);
                        tspan.text(line.join(' '));
                        if (tspan.node().getComputedTextLength() > width) {
                            line.pop();
                            if (line.length > 0) {
                                lineCount++;
                            }
                            line = [word];
                        }
                    }
                    if (line.length > 0) {
                        lineCount++;
                    }
                    
                    tempText.remove();
                    
                    // Return total height needed (with padding)
                    return Math.max(40, lineCount * lineHeight + 20); // Minimum 40px, add 20px padding
                }
                
                // Function to wrap text
                function wrapText(text, width) {
                    text.each(function() {
                        const text = d3.select(this);
                        const words = text.text().split(/\s+/).reverse();
                        let word;
                        let line = [];
                        let lineNumber = 0;
                        const lineHeight = 14;  // Increased line height for better spacing
                        const y = text.attr('y') || 0;
                        
                        // Clear any existing text and tspans
                        text.text(null);
                        
                        // Create first tspan
                        let tspan = text.append('tspan')
                            .attr('x', text.attr('x'))
                            .attr('y', y);
                        
                        while (word = words.pop()) {
                            line.push(word);
                            tspan.text(line.join(' '));
                            if (tspan.node().getComputedTextLength() > width && line.length > 1) {
                                line.pop();
                                tspan.text(line.join(' '));
                                line = [word];
                                lineNumber++;
                                tspan = text.append('tspan')
                                    .attr('x', text.attr('x'))
                                    .attr('y', y)
                                    .attr('dy', (lineNumber * lineHeight) + 'px')
                                    .text(word);
                            }
                        }
                        
                        // Center the text vertically
                        const totalLines = lineNumber + 1;
                        const totalHeight = lineNumber * lineHeight;
                        const startOffset = -totalHeight / 2;
                        
                        text.selectAll('tspan').each(function(d, i) {
                            if (i === 0) {
                                d3.select(this).attr('dy', startOffset + 'px');
                            }
                        });
                    });
                }
                
                // Reapply change indicators after update
                if (window.changeTracker && window.changeTracker.pendingChanges.size > 0) {
                    window.changeTracker.pendingChanges.forEach((nodeChanges, nodeId) => {
                        if (nodeChanges.size > 0) {
                            // Find the node in the tree (could be collapsed or expanded)
                            const treeNode = root.descendants().find(d => d.data.id === nodeId);
                            if (treeNode) {
                                // Apply the change indicator if the node element exists in the DOM
                                const nodeElement = d3.select(`[data-node-id="${nodeId}"]`);
                                if (!nodeElement.empty()) {
                                    if (window.inlineEditor) {
                                        window.inlineEditor.markNodeAsModified(nodeId);
                                    }
                                }
                            }
                        }
                    });
                }
            }
            
            
            // Function to add a new node to the hierarchy
            window.hierarchyVisualization = {
                addNode: function(newNodeData, parentNode) {
                    console.log('Adding new node:', newNodeData, 'to parent:', parentNode);
                    
                    // Find the parent in the hierarchy
                    let parent = null;
                    if (!parentNode || parentNode.type === 'root') {
                        // Adding to root level
                        parent = root;
                    } else {
                        // Find the parent node in the tree
                        parent = root.descendants().find(d => d.data.id === parentNode.id);
                    }
                    
                    if (!parent) {
                        console.error('Parent node not found:', parentNode);
                        return;
                    }
                    
                    // Create the new D3 hierarchy node
                    const newD3Node = d3.hierarchy(newNodeData);
                    newD3Node.depth = parent.depth + 1;
                    newD3Node.parent = parent;
                    
                    // Add to parent's children
                    if (!parent.children) {
                        parent.children = [];
                    }
                    parent.children.push(newD3Node);
                    
                    // If parent was collapsed, expand it to show the new node
                    if (parent._children && !parent.children) {
                        parent.children = parent._children;
                        parent._children = null;
                    }
                    
                    // Update the tree
                    update(parent);
                    
                    console.log('Node added successfully');
                },
                
                updateData: function(newData) {
                    console.log('[HIERARCHY] Updating visualization with new data:', newData);
                    
                    // Store the new data globally
                    window.hierarchyData = newData;
                    
                    // Recreate the hierarchy
                    root = d3.hierarchy(newData);
                    root.x0 = height / 2;
                    root.y0 = 0;
                    
                    // Clear the existing visualization
                    svg.selectAll("g.node").remove();
                    svg.selectAll("path.link").remove();
                    
                    // Collapse after the first level
                    if (root.children) {
                        root.children.forEach(child => {
                            if (child.children) {
                                child._children = child.children;
                                child.children = null;
                            }
                        });
                    }
                    
                    // Update the tree
                    update(root);
                    
                    // Update column headers
                    setTimeout(() => {
                        addColumnHeaders();
                        updateColumnHeaderPositions({ k: 1, x: 100, y: 50 });
                    }, 600);
                    
                    console.log('[HIERARCHY] Visualization updated successfully');
                }
            };
            
            // Initial update
            update(root);
            
            // Add initial column headers after a short delay to ensure layout is complete
            setTimeout(() => {
                addColumnHeaders();
                updateColumnHeaderPositions({ k: 1, x: 100, y: 50 });
            }, 600);
            
            // Apply zoom behavior to svg
            svg.call(zoom);
            
            // Function to update column header positions based on zoom
            function updateColumnHeaderPositions(transform) {
                const scale = transform.k;
                const translateX = transform.x;
                
                d3.select(container).selectAll('.column-header-fixed').each(function() {
                    const column = parseInt(d3.select(this).attr('data-column'));
                    if (!isNaN(column)) {
                        const columnCenterX = translateX + (column * columnWidth * scale);
                        const headerLeft = columnCenterX - (nodeWidth / 2);
                        d3.select(this)
                            .style('left', `${headerLeft}px`)
                            .style('transform', `scale(${Math.max(0.8, Math.min(1, scale))})`);
                    }
                });
            }
            
            // Function to highlight path from root to selected node
            function highlightPath(node) {
                // First, remove all highlights and reset colors
                linksGroup.selectAll('.link')
                    .classed('highlight', false)
                    .attr('stroke', '#DDDBDA'); // Reset all to grey
                
                if (!node) {
                    // If no node selected, apply depth-based colors
                    linksGroup.selectAll('.link')
                        .attr('stroke', d => {
                            const depth = d.source.depth;
                            return linkColors[Math.min(depth, linkColors.length - 1)];
                        });
                    return;
                }
                
                // Get all ancestors of the selected node
                const ancestors = [];
                let current = node;
                while (current.parent) {
                    ancestors.push(current);
                    current = current.parent;
                }
                ancestors.push(current); // Add root
                
                // Highlight links in the path
                linksGroup.selectAll('.link')
                    .classed('highlight', d => {
                        // Check if this link is part of the path
                        for (let i = 0; i < ancestors.length - 1; i++) {
                            if ((d.source === ancestors[i + 1] && d.target === ancestors[i]) ||
                                (d.source === ancestors[i] && d.target === ancestors[i + 1])) {
                                return true;
                            }
                        }
                        return false;
                    });
            }
            
            // Remove the SVG background click handler - we don't want to deselect on background clicks
            // svg.on('click', function() { ... });
            
            // Store references globally for toolbar functions
            window.hierarchySvg = svg;
            window.hierarchyZoom = zoom;
            window.hierarchyRoot = root;
            
            // Store nodes for inline editor
            window.hierarchyData.nodes = root.descendants().map(d => d.data);
            
            // Initialize inline editor if available
            if (window.inlineEditor) {
                window.inlineEditor.initialize();
            }
            
            // Apply any saved changes from session storage
            if (window.changeTracker && window.changeTracker.pendingChanges.size > 0) {
                window.changeTracker.applyRestoredChanges();
            }
        }

        // Load user permissions
        async function loadUserPermissions() {
            try {
                const orgId = localStorage.getItem('selectedOrgId') || 'default';
                console.log('Loading permissions for org:', orgId);
                
                const response = await fetch(`/api/edit/permissions?org_id=${encodeURIComponent(orgId)}`);
                if (response.ok) {
                    const permissions = await response.json();
                    window.userPermissions = permissions;
                    console.log('User permissions loaded:', permissions);
                    
                    // Update UI to show delete capabilities if available
                    updateUIForPermissions();
                } else {
                    console.error('Failed to load permissions:', response.statusText);
                    // Default to view-only permissions
                    window.userPermissions = {
                        permission_level: 'view_only',
                        capabilities: {
                            can_view: true,
                            can_edit_basic: false,
                            can_edit_structure: false,
                            can_delete: false,
                            can_admin: false
                        }
                    };
                }
            } catch (error) {
                console.error('Error loading permissions:', error);
                // Default to view-only permissions on error
                window.userPermissions = {
                    permission_level: 'view_only',
                    capabilities: {
                        can_view: true,
                        can_edit_basic: false,
                        can_edit_structure: false,
                        can_delete: false,
                        can_admin: false
                    }
                };
            }
        }
        
        // Update UI based on user permissions
        function updateUIForPermissions() {
            if (!window.userPermissions) return;
            
            const capabilities = window.userPermissions.capabilities || {};
            
            // Show/hide delete-related UI elements based on permissions
            if (capabilities.can_delete) {
                console.log('User has delete permission');
                // Any global UI updates for delete permission can go here
            }
            
            // Update any other permission-based UI elements
            if (capabilities.can_edit_structure) {
                console.log('User has structure edit permission');
            }
            
            if (capabilities.can_admin) {
                console.log('User has admin permission');
            }
        }
        
        // Initiate node deletion process
        function initiateNodeDeletion(node) {
            console.log('initiateNodeDeletion called with node:', node);
            console.log('Node object keys:', Object.keys(node));
            console.log('Node.data:', node.data);
            console.log('Checking permissions:', window.userPermissions);
            console.log('Capabilities:', window.userPermissions?.capabilities);
            console.log('Can delete?', window.userPermissions?.capabilities?.can_delete);
            
            // Add detailed debug info
            if (node && node.data) {
                console.log('Node ID:', node.data.id);
                console.log('Node Name:', node.data.name);
                console.log('Node Type:', node.data.type);
                console.log('Node Children:', node.children);
                console.log('Node _Children:', node._children);
            }
            
            if (!window.userPermissions || !window.userPermissions.capabilities || !window.userPermissions.capabilities.can_delete) {
                console.log('Permission check failed - showing error modal');
                showModal('Permission Denied', 'You do not have permission to delete nodes.', 'error');
                return;
            }
            
            console.log('Permission check passed, proceeding with deletion...');
            
            const nodeData = node.data || node;
            const hasChildren = (node.children && node.children.length > 0) || (node._children && node._children.length > 0);
            
            console.log('Node data:', nodeData);
            console.log('Has children?', hasChildren);
            console.log('Children:', node.children);
            console.log('Hidden children:', node._children);
            
            if (hasChildren) {
                console.log('Showing deletion dialog for node with children...');
                // Show deletion dialog for nodes with children
                showDeletionDialogForNodeWithChildren(node);
            } else {
                console.log('Showing simple confirmation for leaf node...');
                console.log('showModal function exists?', typeof showModal);
                // Simple confirmation for leaf nodes
                try {
                    const modalContent = `
                        <div class="delete-confirmation-content">
                            <div class="warning-icon">
                                <i class="anticon">
                                    <svg viewBox="64 64 896 896" width="48" height="48" fill="#faad14">
                                        <path d="M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z"/>
                                        <path d="M464 688a48 48 0 1096 0 48 48 0 10-96 0zm24-112h48c4.4 0 8-3.6 8-8V296c0-4.4-3.6-8-8-8h-48c-4.4 0-8 3.6-8 8v272c0 4.4 3.6 8 8 8z"/>
                                    </svg>
                                </i>
                            </div>
                            <p>Are you sure you want to delete <strong>"${nodeData.name}"</strong>?</p>
                            <p class="text-muted">This action will stage the deletion locally. You'll need to commit changes to apply it to Salesforce.</p>
                        </div>
                    `;
                    
                    showModal(
                        'Delete Node',
                        modalContent,
                        'warning',
                        [
                        {
                            text: 'Cancel',
                            className: 'btn-secondary',
                            onClick: () => closeModal()
                        },
                        {
                            text: 'Delete',
                            className: 'btn-danger',
                            onClick: () => {
                                markNodeForDeletion(node);
                                // Show success message before closing
                                showModal(
                                    'Node Deleted',
                                    `<div class="success-message">
                                        <div class="success-icon">
                                            <i class="anticon">
                                                <svg viewBox="64 64 896 896" width="48" height="48" fill="#52c41a">
                                                    <path d="M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm193.5 301.7l-210.6 292a31.8 31.8 0 01-51.7 0L318.5 484.9c-3.8-5.3 0-12.7 6.5-12.7h46.9c10.2 0 19.9 4.9 25.9 13.3l71.2 98.8 157.2-218c6-8.3 15.6-13.3 25.9-13.3H699c6.5 0 10.3 7.4 6.5 12.7z"/>
                                                </svg>
                                            </i>
                                        </div>
                                        <p><strong>"${nodeData.name}"</strong> has been marked for deletion.</p>
                                        <p class="text-muted">Remember to commit your changes to apply them to Salesforce.</p>
                                    </div>`,
                                    'success',
                                    [
                                        {
                                            text: 'OK',
                                            className: 'btn-primary',
                                            onClick: () => closeModal()
                                        }
                                    ]
                                );
                                // Auto-close after 2 seconds
                                setTimeout(() => {
                                    const modal = document.querySelector('.modal-overlay');
                                    if (modal) modal.remove();
                                }, 2000);
                            }
                        }
                    ]
                );
                } catch (error) {
                    console.error('Error showing modal:', error);
                }
            }
        }
        
        // Mark node for deletion (stage it locally)
        function markNodeForDeletion(node, deleteChildren = false, newParentId = null) {
            const nodeData = node.data || node;
            
            // Add to pending deletions in change tracker
            if (window.changeTracker) {
                window.changeTracker.trackDeletion({
                    nodeId: nodeData.id,
                    nodeType: nodeData.type,
                    nodeName: nodeData.name,
                    deleteChildren: deleteChildren,
                    newParentId: newParentId,
                    timestamp: new Date().toISOString()
                });
            }
            
            // Visual indication of pending deletion
            const nodeElement = d3.select(`[data-node-id="${nodeData.id}"]`);
            if (nodeElement) {
                nodeElement.classed('pending-delete', true);
                nodeElement.select('rect')
                    .style('opacity', 0.5)
                    .style('stroke', '#dc3545')
                    .style('stroke-width', '2px')
                    .style('stroke-dasharray', '4,2');
                
                // Add deletion indicator text
                const nodeHeightValue = nodeData._height || 60; // Use stored height or default
                nodeElement.append('text')
                    .attr('class', 'deletion-indicator')
                    .attr('x', 0)
                    .attr('y', -nodeHeightValue/2 - 10)
                    .attr('text-anchor', 'middle')
                    .attr('fill', '#dc3545')
                    .style('font-size', '11px')
                    .style('font-weight', 'bold')
                    .text('PENDING DELETION');
            }
            
            // Update node details panel if this node is selected
            if (selectedNode && selectedNode.data.id === nodeData.id) {
                showNodeDetails(nodeData);
            }
            
            // Show undo option
            showUndoNotification(nodeData);
        }
        
        // Show deletion dialog for nodes with children
        function showDeletionDialogForNodeWithChildren(node) {
            const nodeData = node.data || node;
            const childCount = (node.children ? node.children.length : 0) + (node._children ? node._children.length : 0);
            
            const modalContent = `
                <div class="delete-confirmation-content">
                    <div class="warning-icon">
                        <i class="anticon">
                            <svg viewBox="64 64 896 896" width="48" height="48" fill="#faad14">
                                <path d="M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z"/>
                                <path d="M464 688a48 48 0 1096 0 48 48 0 10-96 0zm24-112h48c4.4 0 8-3.6 8-8V296c0-4.4-3.6-8-8-8h-48c-4.4 0-8 3.6-8 8v272c0 4.4 3.6 8 8 8z"/>
                            </svg>
                        </i>
                    </div>
                    <p><strong>"${nodeData.name}"</strong> has ${childCount} child node${childCount === 1 ? '' : 's'}.</p>
                    <p class="text-muted">Choose how to handle the deletion:</p>
                </div>
                <div class="deletion-options">
                    <div class="deletion-option">
                        <input type="radio" id="reparent-children" name="deletion-option" value="reparent" checked>
                        <label for="reparent-children">
                            <strong>Reparent children</strong>
                            <span class="option-description">Move child nodes to a different parent</span>
                        </label>
                        
                        <div id="parent-selector" style="margin-top: 10px; margin-left: 25px;">
                            <label for="new-parent">Select new parent:</label>
                            <select id="new-parent" class="form-control" style="margin-top: 5px;">
                                <option value="">Loading...</option>
                            </select>
                        </div>
                    </div>
                    
                    <div class="deletion-option">
                        <input type="radio" id="delete-children" name="deletion-option" value="delete">
                        <label for="delete-children">
                            <strong>Delete all children</strong>
                            <span class="option-description">Remove this node and all its descendants</span>
                        </label>
                    </div>
                    
                    <div class="deletion-option">
                        <input type="radio" id="make-inactive" name="deletion-option" value="inactive">
                        <label for="make-inactive">
                            <strong>Make inactive</strong>
                            <span class="option-description">Keep the node but mark it as inactive</span>
                        </label>
                    </div>
                </div>
            `;
            
            showModal(
                'Delete Node with Children',
                modalContent,
                'warning',
                [
                    {
                        text: 'Cancel',
                        className: 'btn-secondary',
                        onClick: () => closeModal()
                    },
                    {
                        text: 'Proceed',
                        className: 'btn-danger',
                        onClick: () => handleDeletionWithChildren(node)
                    }
                ],
                () => {
                    // Load potential parent nodes
                    loadPotentialParents(node);
                    
                    // Handle radio button changes
                    document.querySelectorAll('input[name="deletion-option"]').forEach(radio => {
                        radio.addEventListener('change', (e) => {
                            const parentSelector = document.getElementById('parent-selector');
                            if (e.target.value === 'reparent') {
                                parentSelector.style.display = 'block';
                            } else {
                                parentSelector.style.display = 'none';
                            }
                        });
                    });
                }
            );
        }
        
        // Load potential parent nodes for reparenting
        async function loadPotentialParents(nodeToDelete) {
            const select = document.getElementById('new-parent');
            if (!select) return;
            
            // Get all nodes that could be valid parents
            const validParents = [];
            const nodeType = nodeToDelete.data.type;
            
            // Determine valid parent types based on node type
            const validParentTypes = {
                'catalog': ['root'],
                'category': ['catalog'],
                'subcategory': ['category'],
                'product': ['category', 'subcategory'],
                'component': ['product']
            };
            
            const allowedTypes = validParentTypes[nodeType] || [];
            
            // Traverse the tree to find valid parents
            root.descendants().forEach(d => {
                if (allowedTypes.includes(d.data.type) && d.data.id !== nodeToDelete.data.id) {
                    // Also exclude descendants of the node to delete
                    if (!isDescendantOf(d, nodeToDelete)) {
                        validParents.push({
                            id: d.data.id,
                            name: d.data.name,
                            type: d.data.type,
                            path: getNodePath(d)
                        });
                    }
                }
            });
            
            // Populate the select
            select.innerHTML = '<option value="">-- Select a parent --</option>';
            validParents.forEach(parent => {
                const option = document.createElement('option');
                option.value = parent.id;
                option.textContent = parent.path;
                select.appendChild(option);
            });
        }
        
        // Check if a node is a descendant of another
        function isDescendantOf(node, potentialAncestor) {
            let current = node.parent;
            while (current) {
                if (current === potentialAncestor) return true;
                current = current.parent;
            }
            return false;
        }
        
        // Get the full path of a node
        function getNodePath(node) {
            const path = [];
            let current = node;
            while (current && current.data.type !== 'root') {
                path.unshift(current.data.name);
                current = current.parent;
            }
            return path.join(' > ');
        }
        
        // Handle deletion with children
        function handleDeletionWithChildren(node) {
            const selectedOption = document.querySelector('input[name="deletion-option"]:checked').value;
            
            switch (selectedOption) {
                case 'reparent':
                    const newParentId = document.getElementById('new-parent').value;
                    if (!newParentId) {
                        showModal('Error', 'Please select a new parent for the children.', 'error');
                        return;
                    }
                    markNodeForDeletion(node, false, newParentId);
                    break;
                    
                case 'delete':
                    markNodeForDeletion(node, true);
                    break;
                    
                case 'inactive':
                    markNodeAsInactive(node);
                    break;
            }
            
            closeModal();
        }
        
        // Mark node as inactive instead of deleting
        function markNodeAsInactive(node) {
            const nodeData = node.data || node;
            
            // Track the change
            if (window.changeTracker) {
                window.changeTracker.trackFieldChange(
                    nodeData.id,
                    nodeData.type,
                    'isActive',
                    nodeData.isActive !== undefined ? nodeData.isActive : true,
                    false
                );
            }
            
            // Update the node data
            nodeData.isActive = false;
            
            // Visual indication
            const nodeElement = d3.select(`[data-node-id="${nodeData.id}"]`);
            if (nodeElement) {
                nodeElement.classed('inactive', true);
                nodeElement.select('rect')
                    .style('opacity', 0.6)
                    .style('stroke-dasharray', '2,2');
            }
            
            // Update details panel if selected
            if (selectedNode && selectedNode.data.id === nodeData.id) {
                showNodeDetails(nodeData);
            }
        }
        
        // Show undo notification for deletions
        function showUndoNotification(nodeData) {
            const notification = document.createElement('div');
            notification.className = 'undo-notification';
            notification.innerHTML = `
                <span>Node "${nodeData.name}" marked for deletion</span>
                <button class="btn btn-sm btn-link" onclick="undoDeletion('${nodeData.id}')">Undo</button>
            `;
            
            document.body.appendChild(notification);
            
            // Auto-hide after 5 seconds
            setTimeout(() => {
                notification.remove();
            }, 5000);
        }
        
        // Undo a deletion
        window.undoDeletion = function(nodeId) {
            // Remove from pending deletions
            if (window.changeTracker) {
                window.changeTracker.undoDeletion(nodeId);
            }
            
            // Remove visual indication
            const nodeElement = d3.select(`[data-node-id="${nodeId}"]`);
            if (nodeElement) {
                nodeElement.classed('pending-delete', false);
                nodeElement.select('rect')
                    .style('opacity', 1)
                    .style('stroke', null)
                    .style('stroke-width', null)
                    .style('stroke-dasharray', null);
                
                nodeElement.select('.deletion-indicator').remove();
            }
            
            // Remove notification
            document.querySelector('.undo-notification')?.remove();
        };
        
        // Load org selector and show all connections
        async function loadOrgSelector() {
            try {
                // Check if required libraries are loaded
                const useAntDesign = typeof React !== 'undefined' && typeof ReactDOM !== 'undefined' && typeof antd !== 'undefined';
                console.log('Using Ant Design:', useAntDesign);
                // Get all connections and current session info
                const [connectionsResponse, sessionResponse] = await Promise.all([
                    fetch('/api/connections'),
                    fetch('/api/session')
                ]);
                
                console.log('Connections response:', connectionsResponse.status);
                console.log('Session response:', sessionResponse.status);
                
                let activeConnectionId = null;
                let options = [];
                
                if (sessionResponse.ok) {
                    const sessionData = await sessionResponse.json();
                    if (sessionData.success && sessionData.active_connection) {
                        activeConnectionId = sessionData.active_connection.id;
                    }
                }
                
                if (connectionsResponse.ok) {
                    const connectionsData = await connectionsResponse.json();
                    
                    if (connectionsData.connections && connectionsData.connections.length > 0) {
                        // Create options array for Ant Select
                        options = connectionsData.connections.map(conn => ({
                            value: conn.id,
                            label: conn.cli_alias || conn.name || conn.metadata.username
                        }));
                        
                        const container = document.getElementById('org-selector-container');
                        
                        if (useAntDesign) {
                            // Use Ant Design Select component
                            const { Select } = antd;
                            
                            // Handle org switching
                            const handleChange = async (newConnectionId) => {
                                if (newConnectionId && newConnectionId !== activeConnectionId) {
                                    // Show loading state
                                    document.getElementById('loading').style.display = 'flex';
                                    document.getElementById('hierarchy-container').innerHTML = '';
                                    
                                    try {
                                        // Use the login endpoint to switch connections
                                        const loginResponse = await fetch('/api/login', {
                                            method: 'POST',
                                            headers: {
                                                'Content-Type': 'application/json'
                                            },
                                            body: JSON.stringify({
                                                connection_id: newConnectionId
                                            })
                                        });
                                        
                                        if (loginResponse.ok) {
                                            // Reload the page to use the new connection
                                            location.reload();
                                        } else {
                                            const error = await loginResponse.json();
                                            antd.message.error(`Failed to switch organization: ${error.error || 'Unknown error'}`);
                                            document.getElementById('loading').style.display = 'none';
                                            // Re-render with original value
                                            renderOrgSelector();
                                        }
                                    } catch (error) {
                                        console.error('Error switching organization:', error);
                                        antd.message.error('Failed to switch organization. Please try again.');
                                        document.getElementById('loading').style.display = 'none';
                                        // Re-render with original value
                                        renderOrgSelector();
                                    }
                                }
                            };
                            
                            // Render function
                            const renderOrgSelector = () => {
                                ReactDOM.render(
                                    React.createElement(Select, {
                                        defaultValue: activeConnectionId,
                                        value: activeConnectionId,
                                        onChange: handleChange,
                                        options: options,
                                        placeholder: "Select Organization",
                                        style: { width: '100%' },
                                        popupMatchSelectWidth: false,
                                        placement: 'bottomLeft', // Force dropdown to open downward
                                        dropdownStyle: { 
                                            position: 'fixed',
                                            marginTop: '4px'
                                        },
                                        getPopupContainer: () => document.body, // Render dropdown at body level
                                        dropdownAlign: {
                                            points: ['tl', 'bl'], // Align top-left of dropdown to bottom-left of trigger
                                            offset: [0, 4], // Add 4px vertical offset
                                            overflow: {
                                                adjustX: true,
                                                adjustY: false // Prevent vertical adjustment (force downward)
                                            }
                                        }
                                    }),
                                    container
                                );
                            };
                            
                            renderOrgSelector();
                        } else {
                            // Fallback to regular select
                            const select = document.createElement('select');
                            select.id = 'org-selector';
                            select.className = 'btn btn-secondary';
                            select.style.width = '100%';
                            
                            // Add options
                            options.forEach(opt => {
                                const option = document.createElement('option');
                                option.value = opt.value;
                                option.textContent = opt.label;
                                if (opt.value === activeConnectionId) {
                                    option.selected = true;
                                }
                                select.appendChild(option);
                            });
                            
                            // Add change handler
                            select.addEventListener('change', async (e) => {
                                const newConnectionId = e.target.value;
                                if (newConnectionId && newConnectionId !== activeConnectionId) {
                                    // Show loading state
                                    document.getElementById('loading').style.display = 'flex';
                                    document.getElementById('hierarchy-container').innerHTML = '';
                                    
                                    try {
                                        // Use the login endpoint to switch connections
                                        const loginResponse = await fetch('/api/login', {
                                            method: 'POST',
                                            headers: {
                                                'Content-Type': 'application/json'
                                            },
                                            body: JSON.stringify({
                                                connection_id: newConnectionId
                                            })
                                        });
                                        
                                        if (loginResponse.ok) {
                                            // Reload the page to use the new connection
                                            location.reload();
                                        } else {
                                            const error = await loginResponse.json();
                                            alert(`Failed to switch organization: ${error.error || 'Unknown error'}`);
                                            // Reset to the active connection
                                            select.value = activeConnectionId;
                                            document.getElementById('loading').style.display = 'none';
                                        }
                                    } catch (error) {
                                        console.error('Error switching organization:', error);
                                        alert('Failed to switch organization. Please try again.');
                                        select.value = activeConnectionId;
                                        document.getElementById('loading').style.display = 'none';
                                    }
                                }
                            });
                            
                            container.appendChild(select);
                        }
                    } else {
                        // No connections found
                        const container = document.getElementById('org-selector-container');
                        container.innerHTML = '<span style="color: #999;">No saved connections</span>';
                    }
                } else {
                    // Error loading connections
                    const container = document.getElementById('org-selector-container');
                    container.innerHTML = '<span style="color: #999;">Error loading connections</span>';
                }
            } catch (error) {
                console.error('Error in loadOrgSelector:', error);
                console.error('Error details:', error.message, error.stack);
                const container = document.getElementById('org-selector-container');
                container.innerHTML = '<span style="color: #999;">Error loading connections</span>';
            }
        }

        // Global toolbar functions
        function zoomIn() {
            if (window.hierarchySvg && window.hierarchyZoom) {
                window.hierarchySvg.transition().duration(300).call(window.hierarchyZoom.scaleBy, 1.2);
            }
        }
        
        function zoomOut() {
            if (window.hierarchySvg && window.hierarchyZoom) {
                window.hierarchySvg.transition().duration(300).call(window.hierarchyZoom.scaleBy, 0.8);
            }
        }
        
        function resetView() {
            if (window.hierarchySvg && window.hierarchyZoom) {
                window.hierarchySvg.transition().duration(300).call(window.hierarchyZoom.transform, d3.zoomIdentity.translate(100, 50));
            }
        }
        
        function fitToScreen() {
            if (!window.hierarchySvg || !window.hierarchyRoot) return;
            
            // Get the bounding box of all visible nodes
            const nodes = window.hierarchyRoot.descendants().filter(d => d.x !== undefined && d.y !== undefined);
            if (nodes.length === 0) return;
            
            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            nodes.forEach(d => {
                minX = Math.min(minX, d.x);
                maxX = Math.max(maxX, d.x + 200); // Add node width
                minY = Math.min(minY, d.y);
                maxY = Math.max(maxY, d.y + 60); // Add node height
            });
            
            // Get container dimensions
            const container = document.getElementById('hierarchy-container');
            const width = container.clientWidth;
            const height = container.clientHeight;
            
            // Calculate scale to fit
            const padding = 50;
            const scaleX = (width - padding * 2) / (maxX - minX);
            const scaleY = (height - padding * 2) / (maxY - minY);
            const scale = Math.min(scaleX, scaleY, 1); // Don't zoom in more than 100%
            
            // Calculate translation to center
            const centerX = (minX + maxX) / 2;
            const centerY = (minY + maxY) / 2;
            const translateX = width / 2 - centerX * scale;
            const translateY = height / 2 - centerY * scale;
            
            // Apply transform
            window.hierarchySvg.transition().duration(500)
                .call(window.hierarchyZoom.transform, d3.zoomIdentity
                    .translate(translateX, translateY)
                    .scale(scale));
        }
        
        // Initialize on page load
        // Debug function to find and test delete functionality
        function debugDeleteForNode(nodeName) {
            console.log(`=== DEBUGGING DELETE FOR NODE: ${nodeName} ===`);
            
            // Find all nodes
            const allNodes = d3.selectAll('.node');
            console.log(`Total nodes found: ${allNodes.size()}`);
            
            // Find the specific node
            let targetNode = null;
            allNodes.each(function(d) {
                if (d.data && d.data.name === nodeName) {
                    console.log(`Found node "${nodeName}":`, d.data);
                    targetNode = d;
                    
                    // Check delete icon
                    const deleteIcon = d3.select(this).select('.delete-icon-group');
                    console.log(`Delete icon exists: ${!deleteIcon.empty()}`);
                    if (!deleteIcon.empty()) {
                        console.log(`Delete icon opacity: ${deleteIcon.style('opacity')}`);
                        console.log(`Delete icon display: ${deleteIcon.style('display')}`);
                        console.log(`Delete icon pointer-events: ${deleteIcon.style('pointer-events')}`);
                        
                        // Force make it visible
                        deleteIcon.style('opacity', 1);
                    }
                }
            });
            
            if (targetNode) {
                console.log('Attempting to call initiateNodeDeletion directly...');
                try {
                    initiateNodeDeletion(targetNode);
                } catch (error) {
                    console.error('Error calling initiateNodeDeletion:', error);
                }
            } else {
                console.error(`Node "${nodeName}" not found!`);
            }
        }
        
        // Make it globally available for testing
        window.debugDeleteForNode = debugDeleteForNode;
        
        document.addEventListener('DOMContentLoaded', async () => {
            console.log('DOM loaded');
            
            // Initialize inline editor and change tracker
            if (window.inlineEditor && window.changeTracker) {
                window.inlineEditor.changeTracker = window.changeTracker;
                window.inlineEditor.initialize();
            }
            
            // Ensure AddNodeManager is initialized
            if (!window.addNodeManager && typeof AddNodeManager !== 'undefined') {
                console.log('Creating AddNodeManager instance');
                window.addNodeManager = new AddNodeManager();
            } else if (typeof AddNodeManager === 'undefined') {
                console.error('AddNodeManager class not loaded yet');
            }
            
            // Load user permissions
            await loadUserPermissions();
            
            // Load org selector
            loadOrgSelector();
            
            // Immediately use D3 visualization
            console.log('Using D3 visualization');
            
            // Hide loading and fetch data
            document.getElementById('loading').style.display = 'none';
            const container = document.getElementById('hierarchy-container');
            container.innerHTML = '';
            
            // Fetch and render
            fetch('/api/product-hierarchy')
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    console.log('Data received:', data);
                    if (data.success && data.hierarchy) {
                        // Store original data for filtering
                        originalData = data.hierarchy;
                        currentData = JSON.parse(JSON.stringify(originalData));
                        
                        // Restore filter preferences from sessionStorage
                        const savedActiveFilter = sessionStorage.getItem('hierarchy-activeFilter');
                        const savedSyncedOnly = sessionStorage.getItem('hierarchy-syncedOnly');
                        
                        if (savedActiveFilter) {
                            document.getElementById('activeFilter').value = savedActiveFilter;
                        }
                        if (savedSyncedOnly !== null) {
                            document.getElementById('syncedOnlyFilter').checked = savedSyncedOnly === 'true';
                        }
                        
                        // Apply filters if any are set
                        if ((savedActiveFilter && savedActiveFilter !== 'all') || savedSyncedOnly === 'true') {
                            applyFilters();
                        } else {
                            renderD3Tree(currentData);
                        }
                    } else {
                        // No hierarchy data - show option to load sample data
                        container.innerHTML = `
                            <div class="empty-state" id="empty-state">
                                <i class="fas fa-inbox"></i>
                                <p>No hierarchy data available</p>
                                <button class="btn btn-primary" onclick="loadSampleData()">
                                    Load Sample Data
                                </button>
                            </div>
                        `;
                    }
                })
                .catch(error => {
                    console.error('Error loading data:', error);
                    console.error('Error details:', error.message, error.stack);
                    
                    // Show option to load sample data
                    container.innerHTML = `
                        <div class="empty-state" id="empty-state">
                            <i class="fas fa-exclamation-triangle"></i>
                            <p>Error loading hierarchy data</p>
                            <p style="font-size: 0.875rem; color: #999; margin-bottom: 1rem;">${error.message}</p>
                            <button class="btn btn-primary" onclick="loadSampleData()">
                                Load Sample Data
                            </button>
                        </div>
                    `;
                });
        });
    </script>
</body>
</html>