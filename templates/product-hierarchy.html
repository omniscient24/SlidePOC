<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Product Hierarchy Visualization - Revenue Cloud Migration</title>
    
    <!-- CSS Libraries -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <link href="https://unpkg.com/antd@5.12.8/dist/reset.css" rel="stylesheet">
    <link rel="stylesheet" href="/static/css/style.css">
    <link rel="stylesheet" href="/static/css/edit-indicators.css">
    
    <!-- D3.js for visualizations -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    
    <!-- React and Ant Design for UI components -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/antd@5.12.8/dist/antd.min.js"></script>
    
    <!-- Edit functionality scripts -->
    <script src="/static/js/inline-edit.js"></script>
    <script src="/static/js/change-tracker.js"></script>
    
    <style>
        :root {
            --primary-color: #0176D3;
            --secondary-color: #014486;
            --success-color: #2E844A;
            --warning-color: #FFB75D;
            --error-color: #BA0517;
            --background-color: #F3F3F3;
            --surface-color: #FFFFFF;
            --text-primary: #181818;
            --text-secondary: #514F4D;
            --border-color: #DDDBDA;
            --shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            --shadow-hover: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: var(--background-color);
            color: var(--text-primary);
            line-height: 1.6;
        }

        .header {
            background-color: var(--surface-color);
            border-bottom: 1px solid var(--border-color);
            padding: 1rem 2rem;
            box-shadow: var(--shadow);
        }

        .header-content {
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header h1 {
            font-size: 1.5rem;
            font-weight: 600;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .header-actions {
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        .btn {
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 4px;
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
        }

        .btn-primary {
            background-color: var(--primary-color);
            color: white;
        }

        .btn-primary:hover {
            background-color: var(--secondary-color);
        }

        .btn-secondary {
            background-color: transparent;
            color: var(--primary-color);
            border: 1px solid var(--primary-color);
        }

        .btn-secondary:hover {
            background-color: var(--primary-color);
            color: white;
        }
        
        /* Ant Design Select styling to match our button style */
        #org-selector-container .ant-select {
            min-width: 200px;
        }
        
        #org-selector-container .ant-select-selector {
            background-color: transparent !important;
            color: var(--primary-color) !important;
            border: 1px solid var(--primary-color) !important;
            height: auto !important;
            padding: 0.5rem 1rem !important;
            border-radius: 4px !important;
            font-size: 0.875rem !important;
        }
        
        #org-selector-container .ant-select:hover .ant-select-selector {
            background-color: var(--primary-color) !important;
            color: white !important;
            border-color: var(--primary-color) !important;
        }
        
        #org-selector-container .ant-select:hover .ant-select-arrow {
            color: white !important;
        }
        
        #org-selector-container .ant-select-arrow {
            color: var(--primary-color);
        }
        
        /* Force dropdown to open downward and ensure visibility */
        .ant-select-dropdown {
            z-index: 10000 !important;
        }
        
        /* Add space below header for dropdown */
        .header {
            overflow: visible !important;
        }
        
        .header-actions {
            overflow: visible !important;
        }
        
        /* Organization selector wrapper and label */
        .org-selector-wrapper {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .field-label {
            font-size: 0.875rem;
            font-weight: 500;
            color: var(--text-dark);
            white-space: nowrap;
        }

        .main-container {
            width: 100%;
            margin: 0;
            padding: 1rem;
            display: flex;
            gap: 1rem;
            height: calc(100vh - 120px);
        }

        .visualization-panel {
            flex: 1;
            background-color: var(--surface-color);
            border-radius: 8px;
            box-shadow: var(--shadow);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .visualization-header {
            padding: 1rem;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .visualization-controls {
            display: flex;
            gap: 0.5rem;
        }

        .control-btn {
            width: 32px;
            height: 32px;
            border: 1px solid var(--border-color);
            background-color: var(--surface-color);
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .control-btn:hover {
            background-color: var(--background-color);
            border-color: var(--primary-color);
            color: var(--primary-color);
        }

        #hierarchy-container {
            flex: 1;
            position: relative;
            background-color: #FAFAFA;
        }

        .details-panel {
            width: 400px;
            background-color: var(--surface-color);
            border-radius: 8px;
            box-shadow: var(--shadow);
            display: flex;
            flex-direction: column;
            transition: transform 0.3s ease;
        }

        .details-panel.collapsed {
            transform: translateX(420px);
        }

        .details-header {
            padding: 1rem;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .details-content {
            flex: 1;
            overflow-y: auto;
            padding: 1.5rem;
        }

        .details-section {
            margin-bottom: 2rem;
        }

        .details-section:last-child {
            margin-bottom: 0;
        }

        .section-title {
            font-size: 0.875rem;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            margin-bottom: 1rem;
            letter-spacing: 0.05em;
        }

        .detail-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 0;
            border-bottom: 1px solid var(--background-color);
        }

        .detail-item:last-child {
            border-bottom: none;
        }

        .detail-label {
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .detail-value {
            font-size: 0.875rem;
            font-weight: 500;
            color: var(--text-primary);
        }

        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(255, 255, 255, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .loading-spinner {
            width: 48px;
            height: 48px;
            border: 3px solid var(--border-color);
            border-top-color: var(--primary-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: var(--text-secondary);
        }

        .empty-state i {
            font-size: 3rem;
            margin-bottom: 1rem;
            opacity: 0.5;
        }

        .empty-state p {
            font-size: 1.125rem;
            margin-bottom: 1.5rem;
        }

        /* React Flow Custom Node Styles */
        .custom-node {
            background-color: var(--surface-color);
            border: 2px solid var(--border-color);
            border-radius: 8px;
            padding: 1rem;
            min-width: 200px;
            box-shadow: var(--shadow);
            transition: all 0.2s;
        }

        .custom-node:hover {
            box-shadow: var(--shadow-hover);
            border-color: var(--primary-color);
        }

        .custom-node.selected {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 2px rgba(1, 118, 211, 0.2);
        }

        .node-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
        }

        .node-icon {
            width: 24px;
            height: 24px;
            background-color: var(--primary-color);
            color: white;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.875rem;
        }

        .node-title {
            font-weight: 600;
            font-size: 0.875rem;
            color: var(--text-primary);
        }

        .node-stats {
            display: flex;
            gap: 1rem;
            margin-top: 0.5rem;
        }

        .node-stat {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .stat-value {
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--primary-color);
        }

        .stat-label {
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        /* Custom Edge Styles */
        .react-flow__edge-path {
            stroke: var(--border-color);
            stroke-width: 2;
        }

        .react-flow__edge-path:hover {
            stroke: var(--primary-color);
        }

        /* Toolbar */
        .toolbar {
            position: absolute;
            bottom: 1rem;
            left: 1rem;
            background-color: var(--surface-color);
            border-radius: 8px;
            box-shadow: var(--shadow);
            display: flex;
            gap: 0.25rem;
            padding: 0.5rem;
            z-index: 100;
        }

        .toolbar-btn {
            width: 36px;
            height: 36px;
            border: none;
            background-color: transparent;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .toolbar-btn:hover {
            background-color: var(--background-color);
        }

        .toolbar-btn.active {
            background-color: var(--primary-color);
            color: white;
        }


        /* Breadcrumb */
        .breadcrumb {
            padding: 0.75rem 1rem;
            background-color: var(--background-color);
            border-bottom: 1px solid var(--border-color);
            font-size: 0.875rem;
        }

        .breadcrumb-item {
            color: var(--text-secondary);
            text-decoration: none;
            transition: color 0.2s;
        }

        .breadcrumb-item:hover {
            color: var(--primary-color);
        }

        .breadcrumb-separator {
            margin: 0 0.5rem;
            color: var(--text-secondary);
        }

        .breadcrumb-current {
            color: var(--text-primary);
            font-weight: 500;
        }
        
        /* Column Headers */
        .column-header {
            position: absolute;
            top: 10px;
            text-align: center;
            width: 180px;
            font-size: 0.875rem;
            font-weight: 600;
            color: var(--text-primary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        
        .column-header-color {
            width: 100%;
            height: 4px;
            border-radius: 2px;
            margin-bottom: 6px;
        }
        
        /* Node dragging styles */
        .node.dragging rect {
            opacity: 0.8;
            filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.2));
        }
        
        .node {
            transition: none;
        }
        
        .link {
            pointer-events: none;
            transition: opacity 0.3s ease;
        }
        
        /* Highlight path to selected node */
        .link.highlight {
            stroke: #FF6900 !important; /* Orange color for active path */
            stroke-width: 3px !important;
            opacity: 1 !important;
        }
        
        /* Node hover states */
        .node rect {
            transition: none;
        }
        
        .node:hover rect {
            filter: brightness(1.1) drop-shadow(0 4px 8px rgba(0, 0, 0, 0.15));
            stroke-width: 2px;
        }
        
        /* Selected node styling */
        .node.selected rect {
            stroke-width: 3px !important;
            filter: brightness(1.15) drop-shadow(0 4px 12px rgba(0, 0, 0, 0.25));
        }
        
        .node.selected text {
            font-weight: 600;
        }
        
        /* Style for nodes shown only because they have visible children */
        .node-shown-for-children rect {
            opacity: 0.5;
            stroke-dasharray: 5,5;
        }
        
        .node-shown-for-children text {
            opacity: 0.6;
            font-style: italic;
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="header-content">
            <h1>
                <i class="fas fa-sitemap"></i>
                Product Hierarchy Visualization
            </h1>
            <div class="header-actions">
                <div class="toolbar-right" style="display: flex; align-items: center; gap: 10px;">
                </div>
                <div class="org-selector-wrapper">
                    <label for="org-selector" class="field-label">Org:</label>
                    <div id="org-selector-container" style="min-width: 250px;"></div>
                </div>
                <button class="btn btn-secondary" onclick="window.location.href='/'">
                    <i class="fas fa-arrow-left"></i>
                    Back to Home
                </button>
            </div>
        </div>
    </div>

    <div class="breadcrumb">
        <a href="/" class="breadcrumb-item">Home</a>
        <span class="breadcrumb-separator">/</span>
        <a href="/data-management" class="breadcrumb-item">Data Management</a>
        <span class="breadcrumb-separator">/</span>
        <span class="breadcrumb-current">Product Hierarchy</span>
    </div>

    <div class="main-container">
        <div class="visualization-panel">
            <div class="visualization-header">
                <h2 style="font-size: 1.125rem; font-weight: 600;">Hierarchy View</h2>
                <div class="filter-controls" style="display: flex; align-items: center; gap: 15px; margin-right: 15px;">
                    <label style="display: flex; align-items: center; gap: 5px; font-size: 0.875rem;">
                        Show:
                        <select id="activeFilter" class="filter-select" onchange="applyFilters()" style="padding: 4px 8px; border: 1px solid #DDDBDA; border-radius: 4px; font-size: 0.875rem;">
                            <option value="all">All Items</option>
                            <option value="active">Active Only</option>
                            <option value="inactive">Inactive Only</option>
                        </select>
                    </label>
                    <label style="display: flex; align-items: center; gap: 5px; font-size: 0.875rem;">
                        <input type="checkbox" id="syncedOnlyFilter" onchange="applyFilters()">
                        Synced Only
                    </label>
                </div>
                <div class="visualization-controls">
                    <button class="control-btn" onclick="refreshHierarchy()" title="Refresh Data" style="background-color: #0176D3; color: white;">
                        <i class="fas fa-sync-alt"></i>
                    </button>
                    <button class="control-btn" onclick="fitView()" title="Fit to View">
                        <i class="fas fa-compress"></i>
                    </button>
                    <button class="control-btn" onclick="toggleFullscreen()" title="Fullscreen">
                        <i class="fas fa-expand"></i>
                    </button>
                    <button class="control-btn" onclick="exportImage()" title="Export as Image">
                        <i class="fas fa-download"></i>
                    </button>
                </div>
            </div>
            <div id="hierarchy-container">
                <div class="loading-overlay" id="loading">
                    <div class="loading-spinner"></div>
                </div>
                <div class="empty-state" id="empty-state" style="display: none;">
                    <i class="fas fa-inbox"></i>
                    <p>No hierarchy data available</p>
                    <button class="btn btn-primary" onclick="loadSampleData()">
                        Load Sample Data
                    </button>
                </div>
            </div>
            <div class="toolbar" id="main-toolbar">
                <button class="toolbar-btn" onclick="zoomIn()" title="Zoom In">
                    <i class="fas fa-search-plus"></i>
                </button>
                <button class="toolbar-btn" onclick="zoomOut()" title="Zoom Out">
                    <i class="fas fa-search-minus"></i>
                </button>
                <button class="toolbar-btn" onclick="resetView()" title="Reset View">
                    <i class="fas fa-home"></i>
                </button>
                <button class="toolbar-btn" id="layout-btn" onclick="fitToScreen()" title="Fit to Screen">
                    <i class="fas fa-compress"></i>
                </button>
            </div>
        </div>

        <div class="details-panel" id="details-panel">
            <div class="details-header">
                <h3 style="font-size: 1.125rem; font-weight: 600;">Details</h3>
                <button class="control-btn" onclick="toggleDetailsPanel()">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="details-content" id="details-content">
                <div class="empty-state" style="height: 200px;">
                    <i class="fas fa-mouse-pointer"></i>
                    <p style="font-size: 0.875rem;">Select an item to view details</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let currentLayout = 'vertical';
        let selectedNode = null;
        let originalData = null;
        let currentData = null;
        let d3Root = null;
        let d3Update = null;
        window.hierarchyData = { nodes: [] }; // For inline editor


        // Helper Functions
        function generateSampleData() {
            return {
                id: 'catalog-1',
                name: 'Revenue Cloud Products',
                type: 'catalog',
                children: [
                    {
                        id: 'cat-1',
                        name: 'Software Licenses',
                        type: 'category',
                        children: [
                            {
                                id: 'subcat-1',
                                name: 'Enterprise',
                                type: 'subcategory',
                                children: [
                                    {
                                        id: 'subcat-1-1',
                                        name: 'Core Products',
                                        type: 'subcategory',
                                        children: [
                                            {
                                                id: 'prod-1',
                                                name: 'Revenue Cloud Enterprise',
                                                type: 'product',
                                                price: '$5,000/month',
                                                children: [
                                                    {
                                                        id: 'var-1',
                                                        name: '100 Users',
                                                        type: 'variant',
                                                        price: '$5,000/month'
                                                    },
                                                    {
                                                        id: 'var-2',
                                                        name: '500 Users',
                                                        type: 'variant',
                                                        price: '$20,000/month'
                                                    }
                                                ]
                                            },
                                            {
                                                id: 'prod-2',
                                                name: 'CPQ Enterprise',
                                                type: 'product',
                                                price: '$3,000/month'
                                            }
                                        ]
                                    },
                                    {
                                        id: 'subcat-1-2',
                                        name: 'Add-on Products',
                                        type: 'subcategory',
                                        children: [
                                            {
                                                id: 'prod-6',
                                                name: 'Advanced Analytics',
                                                type: 'product',
                                                price: '$1,000/month'
                                            },
                                            {
                                                id: 'prod-7',
                                                name: 'AI Pricing Optimizer',
                                                type: 'product',
                                                price: '$2,000/month'
                                            }
                                        ]
                                    }
                                ]
                            },
                            {
                                id: 'subcat-2',
                                name: 'Professional',
                                type: 'subcategory',
                                children: [
                                    {
                                        id: 'prod-3',
                                        name: 'Revenue Cloud Professional',
                                        type: 'product',
                                        price: '$1,500/month'
                                    }
                                ]
                            }
                        ]
                    },
                    {
                        id: 'cat-2',
                        name: 'Services',
                        type: 'category',
                        children: [
                            {
                                id: 'subcat-3',
                                name: 'Implementation',
                                type: 'subcategory',
                                children: [
                                    {
                                        id: 'subcat-3-1',
                                        name: 'Standard Services',
                                        type: 'subcategory',
                                        children: [
                                            {
                                                id: 'prod-4',
                                                name: 'Standard Implementation',
                                                type: 'product',
                                                price: '$50,000'
                                            },
                                            {
                                                id: 'prod-8',
                                                name: 'Data Migration Service',
                                                type: 'product',
                                                price: '$25,000'
                                            }
                                        ]
                                    },
                                    {
                                        id: 'subcat-3-2',
                                        name: 'Premium Services',
                                        type: 'subcategory',
                                        children: [
                                            {
                                                id: 'prod-5',
                                                name: 'Enterprise Implementation',
                                                type: 'product',
                                                price: '$150,000'
                                            },
                                            {
                                                id: 'prod-9',
                                                name: 'Custom Integration Package',
                                                type: 'product',
                                                price: '$75,000'
                                            }
                                        ]
                                    }
                                ]
                            }
                        ]
                    }
                ]
            };
        }

        function showNodeDetails(node) {
            console.log('showNodeDetails called with:', node);
            const detailsContent = document.getElementById('details-content');
            
            if (!node) {
                console.error('No node data provided');
                return;
            }
            
            let detailsHTML = `
                <div class="details-section">
                    <div class="section-title">Basic Information</div>
                    <div class="detail-item">
                        <span class="detail-label">Name</span>
                        <span class="detail-value" data-field="name">${node.name || 'Unknown'}</span>
                    </div>
                    <div class="detail-item">
                        <span class="detail-label">Type</span>
                        <span class="detail-value" data-field="type">${(node.type || 'unknown').charAt(0).toUpperCase() + (node.type || 'unknown').slice(1)}</span>
                    </div>
                    <div class="detail-item">
                        <span class="detail-label">ID</span>
                        <span class="detail-value">${node.id || 'N/A'}</span>
                    </div>
                    ${node.productCode !== undefined ? `
                        <div class="detail-item">
                            <span class="detail-label">Product Code</span>
                            <span class="detail-value" data-field="productCode">${node.productCode || ''}</span>
                        </div>
                    ` : ''}
                    ${node.price !== undefined ? `
                        <div class="detail-item">
                            <span class="detail-label">Price</span>
                            <span class="detail-value" data-field="price">${node.price || ''}</span>
                        </div>
                    ` : ''}
                    ${node.isActive !== undefined ? `
                        <div class="detail-item">
                            <span class="detail-label">Status</span>
                            <span class="detail-value" data-field="isActive">${node.isActive ? 'Active' : 'Inactive'}</span>
                        </div>
                    ` : ''}
                    ${node.isBundle ? `
                        <div class="detail-item">
                            <span class="detail-label">Type</span>
                            <span class="detail-value">Bundle Product</span>
                        </div>
                    ` : ''}
                    ${node.quantity !== undefined ? `
                        <div class="detail-item">
                            <span class="detail-label">Quantity</span>
                            <span class="detail-value" data-field="quantity">${node.quantity || ''}</span>
                        </div>
                    ` : ''}
                    ${node.isRequired !== undefined ? `
                        <div class="detail-item">
                            <span class="detail-label">Required</span>
                            <span class="detail-value" data-field="isRequired">${node.isRequired ? 'Yes' : 'No'}</span>
                        </div>
                    ` : ''}
                </div>
            `;

            if (node.stats) {
                detailsHTML += `
                    <div class="details-section">
                        <div class="section-title">Statistics</div>
                        ${node.stats.children !== undefined ? `
                            <div class="detail-item">
                                <span class="detail-label">Direct Children</span>
                                <span class="detail-value">${node.stats.children}</span>
                            </div>
                        ` : ''}
                        ${node.stats.products !== undefined ? `
                            <div class="detail-item">
                                <span class="detail-label">Total Products</span>
                                <span class="detail-value">${node.stats.products}</span>
                            </div>
                        ` : ''}
                        ${node.stats.catalogs !== undefined ? `
                            <div class="detail-item">
                                <span class="detail-label">Total Catalogs</span>
                                <span class="detail-value">${node.stats.catalogs}</span>
                            </div>
                        ` : ''}
                        ${node.stats.categories !== undefined ? `
                            <div class="detail-item">
                                <span class="detail-label">Total Categories</span>
                                <span class="detail-value">${node.stats.categories}</span>
                            </div>
                        ` : ''}
                    </div>
                `;
            }
            
            // Count children if available
            if (node.children && node.children.length > 0) {
                detailsHTML += `
                    <div class="details-section">
                        <div class="section-title">Hierarchy Info</div>
                        <div class="detail-item">
                            <span class="detail-label">Direct Children</span>
                            <span class="detail-value">${node.children.length}</span>
                        </div>
                    </div>
                `;
            }

            detailsHTML += `
                <div class="details-section">
                    <div class="section-title">Actions</div>
                    <button class="btn btn-primary" style="width: 100%; margin-bottom: 0.5rem;" onclick="editNode('${node.id}')">
                        <i class="fas fa-edit"></i>
                        Edit Details
                    </button>
                    <button class="btn btn-secondary" style="width: 100%;" onclick="viewInDataManagement('${node.type}', '${node.id}')">
                        <i class="fas fa-external-link-alt"></i>
                        View in Data Management
                    </button>
                </div>
            `;

            detailsContent.innerHTML = detailsHTML;
        }

        // Control Functions (these will be reimplemented for D3)
        function fitView() {
            // TODO: Implement for D3
        }

        function zoomIn() {
            // TODO: Implement for D3
        }

        function zoomOut() {
            // TODO: Implement for D3
        }

        function resetView() {
            // TODO: Implement for D3
        }

        function toggleLayout() {
            currentLayout = currentLayout === 'vertical' ? 'horizontal' : 'vertical';
            refreshHierarchy();
        }

        function toggleFullscreen() {
            const container = document.querySelector('.visualization-panel');
            if (!document.fullscreenElement) {
                container.requestFullscreen();
            } else {
                document.exitFullscreen();
            }
        }

        function exportImage() {
            // Implement image export functionality
            alert('Export functionality coming soon!');
        }

        function toggleDetailsPanel() {
            const panel = document.getElementById('details-panel');
            panel.classList.toggle('collapsed');
        }

        function refreshHierarchy() {
            document.getElementById('loading').style.display = 'flex';
            // Re-render the component
            renderApp();
        }

        function loadSampleData() {
            document.getElementById('empty-state').style.display = 'none';
            document.getElementById('loading').style.display = 'none';
            const container = document.getElementById('hierarchy-container');
            container.innerHTML = '';
            
            // Use sample data
            const sampleData = generateSampleData();
            originalData = sampleData;
            currentData = JSON.parse(JSON.stringify(originalData));
            renderD3Tree(currentData);
        }

        function editNode(nodeId) {
            // Implement edit functionality
            alert(`Edit functionality for ${nodeId} coming soon!`);
        }

        function viewInDataManagement(type, id) {
            // Navigate to data management with pre-selected object
            window.location.href = `/data-management?type=${type}&id=${id}`;
        }

        
        // Filter functions
        function applyFilters() {
            if (!originalData) return;
            
            const activeFilter = document.getElementById('activeFilter').value;
            const syncedOnly = document.getElementById('syncedOnlyFilter').checked;
            
            // Save filter preferences to sessionStorage
            sessionStorage.setItem('hierarchy-activeFilter', activeFilter);
            sessionStorage.setItem('hierarchy-syncedOnly', syncedOnly);
            
            // Deep clone the original data
            currentData = JSON.parse(JSON.stringify(originalData));
            
            // Clear any previous filter flags
            function clearFilterFlags(node) {
                if (node.shownForChildren) {
                    delete node.shownForChildren;
                }
                if (node.children) {
                    node.children.forEach(clearFilterFlags);
                }
            }
            clearFilterFlags(currentData);
            
            // Apply filters recursively
            filterNode(currentData);
            
            // Re-render the tree
            const container = document.getElementById('hierarchy-container');
            container.innerHTML = '';
            renderD3Tree(currentData);
            
            // Store the hierarchy data globally for other functions to access
            window.hierarchyData = currentData;
            
            function filterNode(node) {
                if (!node) return true;
                
                // First, recursively filter children to determine if any are visible
                let hasVisibleChildren = false;
                if (node.children) {
                    const originalChildren = [...node.children];
                    node.children = node.children.filter(child => filterNode(child));
                    hasVisibleChildren = node.children.length > 0;
                }
                
                // Now check if this node should be visible based on filters
                let nodeMatchesFilter = true;
                
                // Active/Inactive filter (only for nodes with isActive property)
                if (activeFilter !== 'all' && node.isActive !== undefined) {
                    // Check for pending changes to isActive field
                    let effectiveIsActive = node.isActive;
                    if (window.changeTracker && node.id) {
                        const nodeChanges = window.changeTracker.pendingChanges.get(node.id);
                        if (nodeChanges && nodeChanges.has('isActive')) {
                            const change = nodeChanges.get('isActive');
                            effectiveIsActive = change.newValue;
                        }
                    }
                    
                    if (activeFilter === 'active' && !effectiveIsActive) {
                        nodeMatchesFilter = false;
                    } else if (activeFilter === 'inactive' && effectiveIsActive) {
                        nodeMatchesFilter = false;
                    }
                }
                
                // Synced filter
                if (nodeMatchesFilter && syncedOnly) {
                    // Check isSynced flag if available, otherwise check ID format
                    if (node.isSynced !== undefined) {
                        if (!node.isSynced) {
                            nodeMatchesFilter = false;
                        }
                    } else if (node.id) {
                        // Fallback: check if ID looks like a Salesforce ID
                        if (!node.id.startsWith('0') && !node.id.startsWith('a')) {
                            nodeMatchesFilter = false;
                        }
                    }
                }
                
                // Determine final visibility
                if (nodeMatchesFilter) {
                    // Node matches filter criteria - show it normally
                    return true;
                } else if (hasVisibleChildren) {
                    // Node doesn't match but has visible children - show it dimmed
                    node.shownForChildren = true;
                    return true;
                } else {
                    // Node doesn't match and has no visible children - hide it
                    return false;
                }
            }
        }
        
        // D3.js tree visualization with column-based layout
        function renderD3Tree(data) {
            const container = document.getElementById('hierarchy-container');
            const width = container.clientWidth;
            const height = container.clientHeight;
            
            const svg = d3.select(container)
                .append('svg')
                .attr('width', width)
                .attr('height', height);
            
            const g = svg.append('g')
                .attr('transform', 'translate(100, 50)');  // Increased left margin from 50 to 100
            
            // Create separate groups for links and nodes
            const linksGroup = g.append('g').attr('class', 'links');
            const nodesGroup = g.append('g').attr('class', 'nodes');
            
            // Layout configuration
            const columnWidth = 250;  // Fixed width between columns
            const nodeHeight = 60;    // Vertical space per node
            const nodeWidth = 180;    // Width of each node
            const nodePadding = 12;   // Padding inside nodes
            
            // Define zoom behavior early to avoid initialization errors
            const zoom = d3.zoom()
                .scaleExtent([0.5, 2])
                .on('zoom', (event) => {
                    const transform = event.transform;
                    g.attr('transform', transform);
                    // Update column headers positions
                    updateColumnHeaderPositions(transform);
                });
            
            const root = d3.hierarchy(data);
            
            // Set initial collapsed state - start with everything collapsed except root and catalog
            root.descendants().forEach(d => {
                if (d.children && d.children.length > 0) {
                    // Only keep root and catalog expanded, collapse everything else
                    if (d.depth > 1) {  // Collapse everything below catalog level
                        d._children = d.children;
                        d.children = null;
                    }
                }
            });
            
            // Function to prevent overlaps in node positioning
            function preventOverlaps(nodes) {
                // Group nodes by column (X position)
                const nodesByColumn = {};
                nodes.forEach(node => {
                    if (!nodesByColumn[node.x]) {
                        nodesByColumn[node.x] = [];
                    }
                    nodesByColumn[node.x].push(node);
                });
                
                // For each column, ensure no overlaps
                Object.keys(nodesByColumn).forEach(x => {
                    const columnNodes = nodesByColumn[x];
                    // Sort by current Y position
                    columnNodes.sort((a, b) => a.y - b.y);
                    
                    // Adjust positions to prevent overlaps
                    let lastY = null;
                    let lastHeight = 0;
                    columnNodes.forEach((node, i) => {
                        const currentHeight = node.data._height || nodeHeight;
                        if (i === 0) {
                            lastY = node.y;
                            lastHeight = currentHeight;
                        } else {
                            const minY = lastY + (lastHeight / 2) + (currentHeight / 2) + 15; // Dynamic spacing based on node heights
                            if (node.y < minY && !node._manualY) {
                                node.y = minY;
                            }
                            lastY = node.y;
                            lastHeight = currentHeight;
                        }
                    });
                });
            }
            
            // Function to calculate custom layout
            function calculateLayout(root) {
                // Clear any positioned flags to ensure fresh calculation
                root.descendants().forEach(node => {
                    delete node._positioned;
                });
                
                const levels = [];
                const nodesByDepth = {};
                
                // Group nodes by depth
                root.descendants().forEach(d => {
                    if (!nodesByDepth[d.depth]) {
                        nodesByDepth[d.depth] = [];
                    }
                    nodesByDepth[d.depth].push(d);
                });
                
                // Calculate positions for each level
                Object.keys(nodesByDepth).forEach(depth => {
                    const nodesAtDepth = nodesByDepth[depth];
                    const depthNum = parseInt(depth);
                    
                    // Special handling for nodes to position them in correct columns
                    // based on their type and category hierarchy depth
                    const products = nodesAtDepth.filter(n => n.data.type === 'product');
                    const categories = nodesAtDepth.filter(n => n.data.type === 'category' || n.data.type === 'subcategory');
                    const components = nodesAtDepth.filter(n => n.data.type === 'component');
                    
                    // Handle products specially
                    if (products.length > 0) {
                        // Get all visible products
                        const visibleProducts = products.filter(n => n.parent && n.parent.children);
                        console.log(`Handling ${visibleProducts.length} products at depth ${depth}`);
                        
                        if (visibleProducts.length > 0) {
                            // Group products by their parent node
                            const productsByParent = {};
                            visibleProducts.forEach(product => {
                                const parentId = product.parent.data.id || product.parent.data.name;
                                if (!productsByParent[parentId]) {
                                    productsByParent[parentId] = {
                                        parent: product.parent,
                                        products: []
                                    };
                                }
                                productsByParent[parentId].products.push(product);
                            });
                            
                            // Position each group of products
                            Object.values(productsByParent).forEach(group => {
                                const parent = group.parent;
                                const groupProducts = group.products;
                                
                                // Sort products within the group
                                groupProducts.sort((a, b) => {
                                    const aName = a.data.name || '';
                                    const bName = b.data.name || '';
                                    return aName.localeCompare(bName);
                                });
                                
                                // Determine the column based on category depth
                                let categoryDepth = 0;
                                let current = parent;
                                while (current && (current.data.type === 'category' || current.data.type === 'subcategory')) {
                                    categoryDepth++;
                                    current = current.parent;
                                }
                                
                                // Calculate Y position centered around parent
                                const parentY = parent.y;
                                const spacing = 15; // Spacing between nodes
                                const groupHeight = groupProducts.length * (nodeHeight + spacing) - spacing;
                                const startY = parentY - (groupHeight / 2) + (nodeHeight / 2);
                                
                                // Sort products: bundle products first, then non-bundle products
                                groupProducts.sort((a, b) => {
                                    const aHasChildren = (a.children && a.children.length > 0) || (a._children && a._children.length > 0);
                                    const bHasChildren = (b.children && b.children.length > 0) || (b._children && b._children.length > 0);
                                    
                                    // Bundle products (with children) come first
                                    if (aHasChildren && !bHasChildren) return -1;
                                    if (!aHasChildren && bHasChildren) return 1;
                                    
                                    // If both are the same type, maintain their original order
                                    return 0;
                                });
                                
                                // Position products in this group
                                groupProducts.forEach((node, index) => {
                                    // Place products after all category levels
                                    node.x = (1 + categoryDepth + 1) * columnWidth;
                                    node._positioned = true; // Mark as positioned
                                    if (!node._manualY) {
                                        node.y = startY + (index * (nodeHeight + spacing));
                                    }
                                });
                            });
                        }
                    }
                    
                    // Handle categories and subcategories
                    if (categories.length > 0) {
                        categories.forEach(node => {
                            if (node.parent) {
                                // Count category depth from catalog
                                let categoryLevel = 0;
                                let current = node;
                                while (current.parent && (current.parent.data.type === 'category' || current.parent.data.type === 'subcategory')) {
                                    categoryLevel++;
                                    current = current.parent;
                                }
                                
                                // Position in appropriate column
                                // catalog=1, category=2, subcategory1=3, subcategory2=4, etc.
                                node.x = (2 + categoryLevel) * columnWidth;
                                if (!node._manualY) {
                                    node.y = node.parent.y;
                                }
                            }
                        });
                    }
                    
                    // Handle components
                    if (components.length > 0) {
                        // Get all visible components
                        const visibleComponents = nodesAtDepth.filter(n => n.data.type === 'component' && n.parent && n.parent.children);
                        
                        if (visibleComponents.length > 0) {
                            // Group components by their parent product
                            const componentsByProduct = {};
                            visibleComponents.forEach(comp => {
                                const productId = comp.parent.data.id;
                                if (!componentsByProduct[productId]) {
                                    componentsByProduct[productId] = [];
                                }
                                componentsByProduct[productId].push(comp);
                            });
                            
                            // Sort products by Y position
                            const sortedProducts = Object.keys(componentsByProduct).sort((a, b) => {
                                const prodA = visibleComponents.find(c => c.parent.data.id === a).parent;
                                const prodB = visibleComponents.find(c => c.parent.data.id === b).parent;
                                return prodA.y - prodB.y;
                            });
                            
                            let currentY = 50; // Start from top with some padding
                            
                            sortedProducts.forEach(productId => {
                                const components = componentsByProduct[productId];
                                // Sort components by sequence if available
                                components.sort((a, b) => (a.data.sequence || 0) - (b.data.sequence || 0));
                                
                                components.forEach((node, index) => {
                                    // Check if this is actually a component (not a regular product)
                                    if (node.data.type === 'component') {
                                        // Determine the column based on parent product's category depth
                                        let categoryDepth = 0;
                                        let current = node.parent ? node.parent.parent : null;
                                        while (current && (current.data.type === 'category' || current.data.type === 'subcategory')) {
                                            categoryDepth++;
                                            current = current.parent;
                                        }
                                        
                                        // Place components in the bundle components column
                                        // catalog=1, categories..., product=N, component=N+1
                                        node.x = (1 + categoryDepth + 2) * columnWidth;
                                        node._positioned = true; // Mark as positioned
                                        
                                        // Set Y position for components
                                        if (!node._manualY) {
                                            node.y = currentY + (index * (nodeHeight + 15)); // Add 15px spacing
                                        }
                                    } else {
                                        // This is a regular product, position it normally
                                        let categoryDepth = 0;
                                        let current = node.parent;
                                        while (current && (current.data.type === 'category' || current.data.type === 'subcategory')) {
                                            categoryDepth++;
                                            current = current.parent;
                                        }
                                        node.x = (1 + categoryDepth + 1) * columnWidth;
                                        node._positioned = true; // Mark as positioned
                                        
                                        // Set Y position for products
                                        if (!node._manualY) {
                                            node.y = currentY + (index * (nodeHeight + 15)); // Add 15px spacing
                                        }
                                    }
                                });
                                
                                currentY += components.length * (nodeHeight + 15) + 20; // Add spacing between product groups
                            });
                            
                            return; // Skip normal processing for this depth
                        }
                    }
                    
                    // Normal processing for other depths
                    // Group nodes by parent to handle alignment
                    const nodesByParent = {};
                    nodesAtDepth.forEach(node => {
                        // Skip nodes that have already been positioned
                        if (node._positioned || node.data.type === 'product' || node.data.type === 'component') {
                            return;
                        }
                        const parentId = node.parent ? node.parent.data.id : 'root';
                        if (!nodesByParent[parentId]) {
                            nodesByParent[parentId] = [];
                        }
                        nodesByParent[parentId].push(node);
                    });
                    
                    // Position nodes based on their parent's position
                    Object.entries(nodesByParent).forEach(([parentId, siblings]) => {
                        let centerY;
                        
                        if (parentId === 'root') {
                            // Root level - center vertically
                            const totalHeight = siblings.length * nodeHeight;
                            centerY = height / 2;
                        } else {
                            // Find parent node and use its Y position as center
                            const parent = siblings[0].parent;
                            centerY = parent.y;
                        }
                        
                        // Sort siblings if they are products: bundle products first
                        if (siblings.length > 0 && siblings[0].data.type === 'product') {
                            siblings.sort((a, b) => {
                                const aHasChildren = (a.children && a.children.length > 0) || (a._children && a._children.length > 0);
                                const bHasChildren = (b.children && b.children.length > 0) || (b._children && b._children.length > 0);
                                
                                // Bundle products (with children) come first
                                if (aHasChildren && !bHasChildren) return -1;
                                if (!aHasChildren && bHasChildren) return 1;
                                
                                // If both are the same type, maintain their original order
                                return 0;
                            });
                        }
                        
                        // Calculate starting Y position to center siblings around parent
                        const spacing = 15; // Spacing between nodes
                        const totalHeight = siblings.length * (nodeHeight + spacing) - spacing;
                        const startY = centerY - (totalHeight / 2) + (nodeHeight / 2);
                        
                        siblings.forEach((node, index) => {
                            // Determine the appropriate column based on node type and hierarchy
                            let nodeX = depthNum * columnWidth; // Default position
                            
                            if (node.data.type === 'catalog') {
                                nodeX = 1 * columnWidth;
                            } else if (node.data.type === 'category' || node.data.type === 'subcategory') {
                                // Count category depth from catalog
                                let categoryLevel = 0;
                                let current = node;
                                while (current.parent && (current.parent.data.type === 'category' || current.parent.data.type === 'subcategory')) {
                                    categoryLevel++;
                                    current = current.parent;
                                }
                                nodeX = (2 + categoryLevel) * columnWidth;
                            } else if (node.data.type === 'product') {
                                // This should not happen as products are handled specially above
                                // But if it does, position based on parent
                                let categoryDepth = 0;
                                let current = node.parent;
                                while (current && (current.data.type === 'category' || current.data.type === 'subcategory')) {
                                    categoryDepth++;
                                    current = current.parent;
                                }
                                nodeX = (1 + categoryDepth + 1) * columnWidth;
                            } else if (node.data.type === 'component') {
                                // Count category depth of parent product's parent
                                let categoryDepth = 0;
                                let current = node.parent ? node.parent.parent : null;
                                while (current && (current.data.type === 'category' || current.data.type === 'subcategory')) {
                                    categoryDepth++;
                                    current = current.parent;
                                }
                                nodeX = (1 + categoryDepth + 2) * columnWidth;
                            }
                            
                            // Always set X position
                            node.x = nodeX;
                            
                            // Only set Y position if it hasn't been manually set
                            if (!node._manualY) {
                                node.y = startY + (index * (nodeHeight + 15)); // Add 15px spacing
                            }
                        });
                    });
                });
            }
            
            // Function to get column info dynamically based on actual structure
            function getColumnInfo(column) {
                // Base columns that are always the same
                const baseColumns = {
                    0: { label: 'All Catalogs', color: '#014486' },
                    1: { label: 'Product Catalog', color: '#0176D3' }
                };
                
                if (baseColumns[column]) {
                    return baseColumns[column];
                }
                
                // Determine the maximum category depth
                let maxCategoryDepth = 0;
                root.descendants().forEach(d => {
                    if (d.data.type === 'category' || d.data.type === 'subcategory') {
                        let depth = 0;
                        let current = d;
                        while (current.parent && (current.parent.data.type === 'category' || current.parent.data.type === 'subcategory')) {
                            depth++;
                            current = current.parent;
                        }
                        maxCategoryDepth = Math.max(maxCategoryDepth, depth);
                    }
                });
                
                // Dynamically assign columns based on structure
                if (column >= 2 && column < 2 + maxCategoryDepth + 1) {
                    // Category columns
                    const categoryLevel = column - 2;
                    if (categoryLevel === 0) {
                        return { label: 'Category', color: '#00D4FF' };
                    } else if (categoryLevel === 1) {
                        return { label: 'Sub-Category', color: '#9050E9' };
                    } else {
                        return { label: `Sub-Category L${categoryLevel}`, color: '#6B46C1' };
                    }
                } else if (column === 2 + maxCategoryDepth + 1) {
                    // Product column
                    return { label: 'Product', color: '#2E844A' };
                } else if (column === 2 + maxCategoryDepth + 2) {
                    // Bundle Components column
                    return { label: 'Bundle Components', color: '#FF6900' };
                } else {
                    // Any additional columns
                    return { label: 'Product Variant', color: '#FFB75D' };
                }
            }
            
            // Define link colors based on depth
            const linkColors = [
                '#014486',   // Depth 0-1: Dark blue (root to catalog)
                '#0176D3',   // Depth 1-2: Blue (catalog to category)
                '#00D4FF',   // Depth 2-3: Light blue (category to product)
                '#9050E9',   // Depth 3-4: Purple (product to component/subcategory)
                '#FF6900',   // Depth 4-5: Orange (component relationships)
                '#FFB75D'    // Depth 5+: Light orange (deeper levels)
            ];
            
            // Function to add column headers
            function addColumnHeaders() {
                // Get unique depths with visible nodes based on their actual column positions
                const visibleColumns = new Set();
                let maxColumn = 0;
                
                root.descendants().forEach(d => {
                    // Use the actual x position to determine the column
                    const column = Math.round(d.x / columnWidth);
                    visibleColumns.add(column);
                    maxColumn = Math.max(maxColumn, column);
                });
                
                // Ensure all columns from 0 to maxColumn are included
                for (let i = 0; i <= maxColumn; i++) {
                    visibleColumns.add(i);
                }
                
                // Check if headers need updating
                const existingHeaders = d3.select(container).selectAll('.column-header-fixed');
                const existingColumns = new Set();
                existingHeaders.each(function() {
                    const column = parseInt(d3.select(this).attr('data-column'));
                    if (!isNaN(column)) existingColumns.add(column);
                });
                
                // Always remove and rebuild headers to ensure proper alignment
                d3.select(container).selectAll('.column-header-fixed').remove();
                
                // Get current transform of the g element
                const currentTransform = d3.zoomTransform(svg.node());
                const scale = currentTransform.k;
                const translateX = currentTransform.x;
                
                // Add headers for each visible column
                visibleColumns.forEach(column => {
                    const colInfo = getColumnInfo(column);
                    if (colInfo) {
                        // Create a fixed header div outside the SVG
                        // Position at center of column minus half the header width
                        const columnCenterX = 100 + (column * columnWidth * scale) + translateX;
                        const headerLeft = columnCenterX - (nodeWidth / 2);
                        
                        const headerDiv = d3.select(container)
                            .append('div')
                            .attr('class', 'column-header-fixed')
                            .style('position', 'absolute')
                            .style('top', '20px')
                            .style('left', `${headerLeft}px`)
                            .style('width', `${nodeWidth}px`)
                            .style('text-align', 'center')
                            .style('z-index', '10')
                            .attr('data-column', column);  // Store column for comparison
                        
                        // Add color bar
                        headerDiv.append('div')
                            .style('width', '100%')
                            .style('height', '4px')
                            .style('background-color', colInfo.color)
                            .style('border-radius', '2px')
                            .style('margin-bottom', '6px');
                        
                        // Add label
                        headerDiv.append('div')
                            .style('font-size', '0.875rem')
                            .style('font-weight', '600')
                            .style('color', 'var(--text-primary)')
                            .style('text-transform', 'uppercase')
                            .style('letter-spacing', '0.05em')
                            .text(colInfo.label);
                    }
                });
            }
            
            // Function to update the tree
            function update(source) {
                // Apply pending changes to node data before rendering
                if (window.changeTracker && window.changeTracker.pendingChanges.size > 0) {
                    root.descendants().forEach(node => {
                        const nodeId = node.data.id;
                        const nodeChanges = window.changeTracker.pendingChanges.get(nodeId);
                        if (nodeChanges && nodeChanges.size > 0) {
                            nodeChanges.forEach((change, fieldName) => {
                                // Apply the pending change to the node data
                                node.data[fieldName] = change.newValue;
                            });
                        }
                    });
                }
                
                // Get all nodes
                const nodes = root.descendants();
                const links = root.links();
                
                // Calculate custom layout
                calculateLayout(root);
                
                // Prevent overlaps after layout calculation
                preventOverlaps(nodes);
                
                // Don't add column headers here - they'll be added after transitions complete
                
                // Debug: Log node positions
                console.log('Node positions after layout:');
                root.descendants().forEach(d => {
                    if (d.data.type === 'product' || d.data.type === 'category') {
                        console.log(`${d.data.name} (${d.data.type}): x=${d.x}, depth=${d.depth}`);
                    }
                });
                
                // Auto-pan to show expanded content
                if (source && source.children && source.children.length > 0) {
                    // Find the rightmost visible node
                    let maxX = 0;
                    root.descendants().forEach(d => {
                        if (d.children) {  // Only consider visible nodes
                            let effectiveX = d.x;
                            maxX = Math.max(maxX, effectiveX);
                        }
                    });
                    
                    console.log('Max X position:', maxX);
                    console.log('Container width:', container.clientWidth);
                    
                    // Calculate required translation to fit content
                    const containerWidth = container.clientWidth;
                    const contentWidth = maxX + nodeWidth + 100; // Add some padding
                    
                    console.log('Content width:', contentWidth);
                    
                    if (contentWidth > containerWidth) {
                        // Pan left to show the expanded content
                        const currentTransform = d3.zoomTransform(svg.node());
                        const newX = Math.min(100, containerWidth - contentWidth);
                        
                        console.log('Panning to X:', newX);
                        
                        svg.transition()
                            .duration(500)
                            .call(zoom.transform, d3.zoomIdentity
                                .translate(newX, 50)
                                .scale(currentTransform.k));
                    }
                }
                
                // Update links
                const link = linksGroup.selectAll('.link')
                    .data(links, d => d.source.id + '-' + d.target.id);
                
                // Remove old links
                link.exit().remove();
                
                // Enter new links
                const linkEnter = link.enter().append('path')
                    .attr('class', 'link')
                    .attr('fill', 'none')
                    .attr('stroke', d => {
                        // Use source node's depth to determine color
                        const depth = d.source.depth;
                        return linkColors[Math.min(depth, linkColors.length - 1)];
                    })
                    .attr('stroke-width', 2)
                    .attr('opacity', 0.6);
                
                // Update all links
                link.merge(linkEnter)
                    .attr('stroke', d => {
                        // Ensure color is maintained on update
                        const depth = d.source.depth;
                        return linkColors[Math.min(depth, linkColors.length - 1)];
                    })
                    .transition()
                    .duration(500)
                    .attr('d', d => {
                        const sourceX = d.source.x + nodeWidth / 2;
                        const sourceY = d.source.y;
                        const targetX = d.target.x - nodeWidth / 2;
                        const targetY = d.target.y;
                        
                        // Create a smooth curve
                        return `M${sourceX},${sourceY}
                                C${sourceX + 50},${sourceY}
                                 ${targetX - 50},${targetY}
                                 ${targetX},${targetY}`;
                    });
                
                // Update nodes
                const node = nodesGroup.selectAll('.node')
                    .data(nodes, d => d.data.id);
                
                // Remove old nodes
                node.exit()
                    .transition()
                    .duration(500)
                    .style('opacity', 0)
                    .remove();
                
                // Enter new nodes
                const nodeEnter = node.enter().append('g')
                    .attr('class', d => 'node' + (d.data.shownForChildren ? ' node-shown-for-children' : ''))
                    .attr('data-node-id', d => d.data.id)
                    .attr('transform', d => `translate(${d.x},${d.y})`)
                    .style('opacity', 0);
                
                // Update all nodes
                node.merge(nodeEnter)
                    .attr('class', d => 'node' + (d.data.shownForChildren ? ' node-shown-for-children' : ''))
                    .transition()
                    .duration(500)
                    .style('opacity', 1)
                    .attr('transform', d => `translate(${d.x},${d.y})`)
                    .on('end', function() {
                        // Update column headers after all transitions complete
                        // Only do this once, on the first node's transition end
                        if (this === node.merge(nodeEnter).node()) {
                            addColumnHeaders();
                            const currentTransform = d3.zoomTransform(svg.node());
                            updateColumnHeaderPositions(currentTransform);
                        }
                    });
                
                // Update text content for existing nodes (to reflect pending changes)
                node.select('text')
                    .text(d => d.data.name);
                
                // Re-apply text wrapping and update rectangle height for updated nodes
                node.each(function(d) {
                    const nodeEl = d3.select(this);
                    const text = nodeEl.select('text');
                    const rect = nodeEl.select('rect');
                    
                    if (!text.empty()) {
                        // Calculate new height if needed
                        const textHeight = calculateTextHeight(d.data.name, nodeWidth - 40);
                        d.data._height = textHeight;
                        
                        // Update rectangle height and position
                        if (!rect.empty()) {
                            rect.attr('height', textHeight)
                                .attr('y', -textHeight / 2);
                        }
                        
                        // Wrap text
                        wrapText(text, nodeWidth - 40); // Leave space for expand button
                    }
                });
                
                // Add vertical-only drag behavior
                const drag = d3.drag()
                    .clickDistance(20) // Increase click distance threshold
                    .on('start', function(event, d) {
                        console.log('Drag started');
                        d3.select(this).raise().style('cursor', 'grabbing');
                        // Store the original x position to lock horizontal movement
                        d._fixedX = d.x;
                    })
                    .on('drag', function(event, d) {
                        // Only allow vertical movement
                        const proposedY = event.y;
                        
                        // Get all nodes in the same column
                        const nodesInSameColumn = nodes.filter(n => {
                            return n !== d && n.x === d.x;
                        });
                        
                        // Define minimum spacing between nodes
                        const draggedNodeHeight = d.data._height || nodeHeight;
                        const minSpacing = 15; // Just the gap, not including node heights
                        
                        // Check for collisions and find the constrained Y position
                        let constrainedY = proposedY;
                        
                        // Sort nodes in the same column by Y position
                        const sortedColumnNodes = nodesInSameColumn.sort((a, b) => a.y - b.y);
                        
                        // Find the closest nodes above and below
                        let nodeAbove = null;
                        let nodeBelow = null;
                        
                        for (const node of sortedColumnNodes) {
                            if (node.y < d.y && (!nodeAbove || node.y > nodeAbove.y)) {
                                nodeAbove = node;
                            }
                            if (node.y > d.y && (!nodeBelow || node.y < nodeBelow.y)) {
                                nodeBelow = node;
                            }
                        }
                        
                        // Constrain Y position to prevent overlap
                        if (nodeAbove) {
                            const aboveHeight = nodeAbove.data._height || nodeHeight;
                            const minY = nodeAbove.y + (aboveHeight / 2) + (draggedNodeHeight / 2) + minSpacing;
                            if (constrainedY < minY) {
                                constrainedY = minY;
                            }
                        }
                        if (nodeBelow) {
                            const belowHeight = nodeBelow.data._height || nodeHeight;
                            const maxY = nodeBelow.y - (belowHeight / 2) - (draggedNodeHeight / 2) - minSpacing;
                            if (constrainedY > maxY) {
                                constrainedY = maxY;
                            }
                        }
                        
                        // Calculate the actual movement
                        const deltaY = constrainedY - d.y;
                        
                        // Update the dragged node's position
                        d.y = constrainedY;
                        d._manualY = true;
                        d.x = d._fixedX; // Keep x position fixed
                        
                        // If this is a product being dragged, move all its expanded components
                        if (d.data.type === 'product' && d.children) {
                            d.children.forEach(child => {
                                if (child.data.type === 'component') {
                                    child.y += deltaY;
                                    child._manualY = true;
                                    // Update component visual position
                                    d3.select(`[data-node-id="${child.data.id}"]`)
                                        .transition()
                                        .duration(0)
                                        .attr('transform', `translate(${child.x},${child.y})`);
                                }
                            });
                        }
                        
                        // Update node position
                        d3.select(this)
                            .attr('transform', `translate(${d.x},${d.y})`);
                        
                        // Update all links in the visualization
                        linksGroup.selectAll('.link')
                            .attr('d', l => {
                                const sourceX = l.source.x + nodeWidth / 2;
                                const sourceY = l.source.y;
                                const targetX = l.target.x - nodeWidth / 2;
                                const targetY = l.target.y;
                                
                                return `M${sourceX},${sourceY}
                                        C${sourceX + 50},${sourceY}
                                         ${targetX - 50},${targetY}
                                         ${targetX},${targetY}`;
                            });
                    })
                    .on('end', function(event, d) {
                        d3.select(this).style('cursor', 'grab');
                    });
                
                // Apply drag to node groups (not the rect itself)
                nodeEnter.style('cursor', 'grab').call(drag);
                node.style('cursor', 'grab').call(drag);
                
                // For all nodes (enter + update), build their content
                nodesGroup.selectAll('.node').each(function(d) {
                    const node = d3.select(this);
                    
                    // Track if dragging
                    let isDragging = false;
                    
                    // Add pointerdown handler to track potential clicks
                    node.on('pointerdown.details', function(event, d) {
                        isDragging = false;
                        const startX = event.clientX;
                        const startY = event.clientY;
                        
                        const checkClick = function(e) {
                            const dx = e.clientX - startX;
                            const dy = e.clientY - startY;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            
                            if (distance > 5) {
                                isDragging = true;
                            }
                        };
                        
                        const handlePointerUp = function(e) {
                            const dx = e.clientX - startX;
                            const dy = e.clientY - startY;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            
                            if (!isDragging && distance < 5) {
                                console.log('Node clicked (pointer):', d.data.name);
                                event.stopPropagation();
                                
                                // Toggle selection if clicking the same node
                                if (selectedNode === d) {
                                    // Deselect the node
                                    selectedNode = null;
                                    nodesGroup.selectAll('.node').classed('selected', false);
                                    highlightPath(null); // This will restore depth-based colors
                                    // Clear details panel
                                    document.getElementById('details-content').innerHTML = '<p class="text-muted">Select a node to view details</p>';
                                } else {
                                    // Select the new node
                                    nodesGroup.selectAll('.node')
                                        .classed('selected', n => n === d);
                                    
                                    // Highlight path from root to selected node
                                    highlightPath(d);
                                    
                                    selectedNode = d;
                                    // Store globally for inline editor
                                    window.selectedNode = d;
                                    
                                    showNodeDetails(d.data || d);
                                    
                                    // Enable inline editing for the details panel
                                    if (window.inlineEditor) {
                                        setTimeout(() => {
                                            window.inlineEditor.enableEditMode();
                                        }, 100);
                                    }
                                }
                            }
                            
                            // Clean up
                            window.removeEventListener('pointermove', checkClick);
                            window.removeEventListener('pointerup', handlePointerUp);
                        };
                        
                        window.addEventListener('pointermove', checkClick);
                        window.addEventListener('pointerup', handlePointerUp);
                    });
                    
                    // For existing nodes, remove old expand/collapse circles to rebuild them
                    node.selectAll('.expand-collapse-circle').remove();
                    
                    // Build content for new nodes
                    if (node.selectAll('rect').empty()) {
                        // Calculate required height based on text
                        const textHeight = calculateTextHeight(d.data.name, nodeWidth - 40);
                        d.data._height = textHeight; // Store height on the data
                        
                        // Add rectangle
                        const rect = node.append('rect')
                            .attr('width', nodeWidth)
                            .attr('height', textHeight)
                            .attr('x', -nodeWidth / 2)
                            .attr('y', -textHeight / 2)
                            .attr('rx', 6)
                            .attr('fill', d => {
                                // Lighter fill colors (15% opacity for better contrast with stroke)
                                const fillColors = {
                                    'root': 'rgba(1, 68, 134, 0.15)',      // Light version of #014486
                                    'catalog': 'rgba(1, 118, 211, 0.15)',  // Light version of #0176D3
                                    'category': 'rgba(0, 212, 255, 0.15)', // Light version of #00D4FF
                                    'subcategory': 'rgba(144, 80, 233, 0.15)',
                                    'product': 'rgba(46, 132, 74, 0.15)',  // Light version of #2E844A
                                    'component': 'rgba(255, 105, 0, 0.15)', // Light version of #FF6900
                                    'variant': 'rgba(255, 183, 93, 0.15)'
                                };
                                return fillColors[d.data.type] || 'rgba(81, 79, 77, 0.15)';
                            })
                            .style('stroke', d => {
                                // Original colors for outlines - using style instead of attr
                                const strokeColors = {
                                    'root': '#014486',      // Dark blue for root
                                    'catalog': '#0176D3',   // Primary blue for catalogs
                                    'category': '#00D4FF',  // Light blue for categories
                                    'subcategory': '#9050E9',
                                    'product': '#2E844A',   // Green for products
                                    'component': '#FF6900', // Orange for bundle components
                                    'variant': '#FFB75D'
                                };
                                return strokeColors[d.data.type] || '#514F4D';
                            })
                            .style('stroke-width', '1px')
                            .style('stroke-opacity', '1')
                            .style('stroke-linejoin', 'round')
                            .style('cursor', 'grab')
                            .on('mouseenter', function(event, d) {
                                // On hover, increase fill opacity
                                d3.select(this)
                                    .attr('fill', d => {
                                        // Darker fill colors (30% opacity on hover)
                                        const hoverFillColors = {
                                            'root': 'rgba(1, 68, 134, 0.3)',
                                            'catalog': 'rgba(1, 118, 211, 0.3)',
                                            'category': 'rgba(0, 212, 255, 0.3)',
                                            'subcategory': 'rgba(144, 80, 233, 0.3)',
                                            'product': 'rgba(46, 132, 74, 0.3)',
                                            'component': 'rgba(255, 105, 0, 0.3)',
                                            'variant': 'rgba(255, 183, 93, 0.3)'
                                        };
                                        return hoverFillColors[d.data.type] || 'rgba(81, 79, 77, 0.3)';
                                    });
                            })
                            .on('mouseleave', function(event, d) {
                                // On mouse leave, return to original fill
                                d3.select(this)
                                    .attr('fill', d => {
                                        const fillColors = {
                                            'root': 'rgba(1, 68, 134, 0.15)',
                                            'catalog': 'rgba(1, 118, 211, 0.15)',
                                            'category': 'rgba(0, 212, 255, 0.15)',
                                            'subcategory': 'rgba(144, 80, 233, 0.15)',
                                            'product': 'rgba(46, 132, 74, 0.15)',
                                            'component': 'rgba(255, 105, 0, 0.15)',
                                            'variant': 'rgba(255, 183, 93, 0.15)'
                                        };
                                        return fillColors[d.data.type] || 'rgba(81, 79, 77, 0.15)';
                                    });
                            })
                            .style('pointer-events', 'all');
                        
                        // Add text
                        const text = node.append('text')
                            .attr('text-anchor', 'start')
                            .attr('x', -nodeWidth / 2 + 10)  // 10px padding from left edge
                            .attr('dy', '0.35em')
                            .attr('fill', d => {
                                // Use dark text color for better contrast on light backgrounds
                                return '#181818'; // var(--text-primary)
                            })
                            .style('font-weight', '600')
                            .style('font-size', '12px')
                            .style('pointer-events', 'none')
                            .style('user-select', 'none')
                            .text(d.data.name);
            
                        // Always wrap text to ensure proper formatting
                        wrapText(text, nodeWidth - 40); // Leave space for expand button
                    }
                    
                    // Add expand/collapse circle if node has children (rebuild for all nodes)
                    if (d._children || d.children) {
                            // Node is expanded if it has visible children
                            const isExpanded = d.children && d.children.length > 0;
                            
                            // Add circle background
                            // Position at the right end of the node
                            const xPosition = nodeWidth / 2 + 10;
                            const circleGroup = node.append('g')
                                .attr('transform', `translate(${xPosition}, 0)`)
                                .attr('class', 'expand-collapse-circle')
                                .style('cursor', 'pointer')
                                .style('pointer-events', 'all')
                                .on('mouseenter', function(event, d) {
                                    // Hover effect for circle
                                    d3.select(this).select('circle')
                                        .attr('fill', 'rgba(1, 118, 211, 0.1)')
                                        .attr('stroke', '#0176D3')
                                        .attr('stroke-width', 2);
                                })
                                .on('mouseleave', function(event, d) {
                                    // Return to normal state
                                    d3.select(this).select('circle')
                                        .attr('fill', '#fff')
                                        .attr('stroke', '#DDDBDA')
                                        .attr('stroke-width', 1.5);
                                })
                                .on('mousedown', function(event, d) {
                                    event.stopPropagation();
                                    event.preventDefault();
                                    // Toggle children on mousedown instead of click
                                    if (d.children) {
                                        d._children = d.children;
                                        d.children = null;
                                    } else {
                                        d.children = d._children;
                                        d._children = null;
                                    }
                                    // Reset manual Y positions when expanding/collapsing to allow proper layout
                                    root.descendants().forEach(node => {
                                        delete node._manualY;
                                    });
                                    update(d);
                                });
                            
                            // Circle background
                            const circle = circleGroup.append('circle')
                                .attr('r', 10)
                                .attr('fill', '#fff')
                                .attr('stroke', '#DDDBDA')
                                .attr('stroke-width', 1.5)
                                .style('transition', 'none')  // Instant hover effect
                                .style('pointer-events', 'all');  // Ensure circle captures events
                            
                            // Plus/minus icon
                            const iconSize = 6;
                            // Horizontal line (always visible)
                            circleGroup.append('line')
                                .attr('x1', -iconSize)
                                .attr('x2', iconSize)
                                .attr('y1', 0)
                                .attr('y2', 0)
                                .attr('stroke', '#514F4D')
                                .attr('stroke-width', 1.5)
                                .style('pointer-events', 'none');  // Don't capture mouse events
                            
                            // Vertical line (only for collapsed nodes - shows plus)
                            if (!isExpanded) {
                                circleGroup.append('line')
                                    .attr('class', 'vertical-line')
                                    .attr('x1', 0)
                                    .attr('x2', 0)
                                    .attr('y1', -iconSize)
                                    .attr('y2', iconSize)
                                    .attr('stroke', '#514F4D')
                                    .attr('stroke-width', 1.5)
                                    .style('pointer-events', 'none');  // Don't capture mouse events
                        }
                    }
                    
                    // Update selected node styling
                    node.classed('selected', d => selectedNode === d);
                    
                    // Maintain highlighted path if a node is selected
                    if (selectedNode) {
                        highlightPath(selectedNode);
                    }
                    
                    // Update stroke for unsynced items
                    node.select('rect')
                        .attr('stroke-dasharray', d => {
                            // Dashed border for unsynced items
                            const isSynced = d.data.isSynced !== undefined ? d.data.isSynced : 
                                           (d.data.id && (d.data.id.startsWith('0') || d.data.id.startsWith('a')));
                            return !isSynced ? '4,2' : 'none';
                        });
                });
            
                // Function to calculate text height after wrapping
                function calculateTextHeight(textString, width) {
                    // Create a temporary text element to measure
                    const tempText = svg.append('text')
                        .style('visibility', 'hidden')
                        .text(textString);
                    
                    const words = textString.split(/\s+/).reverse();
                    let word;
                    let line = [];
                    let lineCount = 0;
                    const lineHeight = 14; // Line height in pixels
                    
                    const tspan = tempText.append('tspan');
                    
                    while (word = words.pop()) {
                        line.push(word);
                        tspan.text(line.join(' '));
                        if (tspan.node().getComputedTextLength() > width) {
                            line.pop();
                            if (line.length > 0) {
                                lineCount++;
                            }
                            line = [word];
                        }
                    }
                    if (line.length > 0) {
                        lineCount++;
                    }
                    
                    tempText.remove();
                    
                    // Return total height needed (with padding)
                    return Math.max(40, lineCount * lineHeight + 20); // Minimum 40px, add 20px padding
                }
                
                // Function to wrap text
                function wrapText(text, width) {
                    text.each(function() {
                        const text = d3.select(this);
                        const words = text.text().split(/\s+/).reverse();
                        let word;
                        let line = [];
                        let lineNumber = 0;
                        const lineHeight = 10;  // Optimal spacing for multi-line text
                        const y = text.attr('y') || 0;
                        const dy = parseFloat(text.attr('dy') || 0);
                        let tspan = text.text(null).append('tspan').attr('x', text.attr('x')).attr('y', y).attr('dy', dy + 'em');
                        
                        while (word = words.pop()) {
                            line.push(word);
                            tspan.text(line.join(' '));
                            if (tspan.node().getComputedTextLength() > width) {
                                line.pop();
                                tspan.text(line.join(' '));
                                line = [word];
                                tspan = text.append('tspan')
                                    .attr('x', text.attr('x'))  // Maintain the same x position for all lines
                                    .attr('y', y)
                                    .attr('dy', lineHeight + 'px')
                                    .text(word);
                                lineNumber++;
                            }
                        }
                        
                        // Center the text vertically with adjusted spacing
                        const totalHeight = lineNumber * lineHeight;
                        text.selectAll('tspan').attr('dy', function(d, i) {
                            return i === 0 ? -totalHeight/2 + 'px' : lineHeight + 'px';
                        });
                    });
                }
                
                // Reapply change indicators after update
                if (window.changeTracker && window.changeTracker.pendingChanges.size > 0) {
                    window.changeTracker.pendingChanges.forEach((nodeChanges, nodeId) => {
                        if (nodeChanges.size > 0) {
                            // Find the node in the tree (could be collapsed or expanded)
                            const treeNode = root.descendants().find(d => d.data.id === nodeId);
                            if (treeNode) {
                                // Apply the change indicator if the node element exists in the DOM
                                const nodeElement = d3.select(`[data-node-id="${nodeId}"]`);
                                if (!nodeElement.empty()) {
                                    if (window.inlineEditor) {
                                        window.inlineEditor.markNodeAsModified(nodeId);
                                    }
                                }
                            }
                        }
                    });
                }
            }
            
            
            // Initial update
            update(root);
            
            // Add initial column headers after a short delay to ensure layout is complete
            setTimeout(() => {
                addColumnHeaders();
                updateColumnHeaderPositions({ k: 1, x: 100, y: 50 });
            }, 600);
            
            // Apply zoom behavior to svg
            svg.call(zoom);
            
            // Function to update column header positions based on zoom
            function updateColumnHeaderPositions(transform) {
                const scale = transform.k;
                const translateX = transform.x;
                
                d3.select(container).selectAll('.column-header-fixed').each(function() {
                    const column = parseInt(d3.select(this).attr('data-column'));
                    if (!isNaN(column)) {
                        const columnCenterX = translateX + (column * columnWidth * scale);
                        const headerLeft = columnCenterX - (nodeWidth / 2);
                        d3.select(this)
                            .style('left', `${headerLeft}px`)
                            .style('transform', `scale(${Math.max(0.8, Math.min(1, scale))})`);
                    }
                });
            }
            
            // Function to highlight path from root to selected node
            function highlightPath(node) {
                // First, remove all highlights and reset colors
                linksGroup.selectAll('.link')
                    .classed('highlight', false)
                    .attr('stroke', '#DDDBDA'); // Reset all to grey
                
                if (!node) {
                    // If no node selected, apply depth-based colors
                    linksGroup.selectAll('.link')
                        .attr('stroke', d => {
                            const depth = d.source.depth;
                            return linkColors[Math.min(depth, linkColors.length - 1)];
                        });
                    return;
                }
                
                // Get all ancestors of the selected node
                const ancestors = [];
                let current = node;
                while (current.parent) {
                    ancestors.push(current);
                    current = current.parent;
                }
                ancestors.push(current); // Add root
                
                // Highlight links in the path
                linksGroup.selectAll('.link')
                    .classed('highlight', d => {
                        // Check if this link is part of the path
                        for (let i = 0; i < ancestors.length - 1; i++) {
                            if ((d.source === ancestors[i + 1] && d.target === ancestors[i]) ||
                                (d.source === ancestors[i] && d.target === ancestors[i + 1])) {
                                return true;
                            }
                        }
                        return false;
                    });
            }
            
            // Remove the SVG background click handler - we don't want to deselect on background clicks
            // svg.on('click', function() { ... });
            
            // Store references globally for toolbar functions
            window.hierarchySvg = svg;
            window.hierarchyZoom = zoom;
            window.hierarchyRoot = root;
            
            // Store nodes for inline editor
            window.hierarchyData.nodes = root.descendants().map(d => d.data);
            
            // Initialize inline editor if available
            if (window.inlineEditor) {
                window.inlineEditor.initialize();
            }
            
            // Apply any saved changes from session storage
            if (window.changeTracker && window.changeTracker.pendingChanges.size > 0) {
                window.changeTracker.applyRestoredChanges();
            }
        }

        // Load org selector and show all connections
        async function loadOrgSelector() {
            try {
                // Check if required libraries are loaded
                const useAntDesign = typeof React !== 'undefined' && typeof ReactDOM !== 'undefined' && typeof antd !== 'undefined';
                console.log('Using Ant Design:', useAntDesign);
                // Get all connections and current session info
                const [connectionsResponse, sessionResponse] = await Promise.all([
                    fetch('/api/connections'),
                    fetch('/api/session')
                ]);
                
                console.log('Connections response:', connectionsResponse.status);
                console.log('Session response:', sessionResponse.status);
                
                let activeConnectionId = null;
                let options = [];
                
                if (sessionResponse.ok) {
                    const sessionData = await sessionResponse.json();
                    if (sessionData.success && sessionData.active_connection) {
                        activeConnectionId = sessionData.active_connection.id;
                    }
                }
                
                if (connectionsResponse.ok) {
                    const connectionsData = await connectionsResponse.json();
                    
                    if (connectionsData.connections && connectionsData.connections.length > 0) {
                        // Create options array for Ant Select
                        options = connectionsData.connections.map(conn => ({
                            value: conn.id,
                            label: conn.cli_alias || conn.name || conn.metadata.username
                        }));
                        
                        const container = document.getElementById('org-selector-container');
                        
                        if (useAntDesign) {
                            // Use Ant Design Select component
                            const { Select } = antd;
                            
                            // Handle org switching
                            const handleChange = async (newConnectionId) => {
                                if (newConnectionId && newConnectionId !== activeConnectionId) {
                                    // Show loading state
                                    document.getElementById('loading').style.display = 'flex';
                                    document.getElementById('hierarchy-container').innerHTML = '';
                                    
                                    try {
                                        // Use the login endpoint to switch connections
                                        const loginResponse = await fetch('/api/login', {
                                            method: 'POST',
                                            headers: {
                                                'Content-Type': 'application/json'
                                            },
                                            body: JSON.stringify({
                                                connection_id: newConnectionId
                                            })
                                        });
                                        
                                        if (loginResponse.ok) {
                                            // Reload the page to use the new connection
                                            location.reload();
                                        } else {
                                            const error = await loginResponse.json();
                                            antd.message.error(`Failed to switch organization: ${error.error || 'Unknown error'}`);
                                            document.getElementById('loading').style.display = 'none';
                                            // Re-render with original value
                                            renderOrgSelector();
                                        }
                                    } catch (error) {
                                        console.error('Error switching organization:', error);
                                        antd.message.error('Failed to switch organization. Please try again.');
                                        document.getElementById('loading').style.display = 'none';
                                        // Re-render with original value
                                        renderOrgSelector();
                                    }
                                }
                            };
                            
                            // Render function
                            const renderOrgSelector = () => {
                                ReactDOM.render(
                                    React.createElement(Select, {
                                        defaultValue: activeConnectionId,
                                        value: activeConnectionId,
                                        onChange: handleChange,
                                        options: options,
                                        placeholder: "Select Organization",
                                        style: { width: '100%' },
                                        popupMatchSelectWidth: false,
                                        placement: 'bottomLeft', // Force dropdown to open downward
                                        dropdownStyle: { 
                                            position: 'fixed',
                                            marginTop: '4px'
                                        },
                                        getPopupContainer: () => document.body, // Render dropdown at body level
                                        dropdownAlign: {
                                            points: ['tl', 'bl'], // Align top-left of dropdown to bottom-left of trigger
                                            offset: [0, 4], // Add 4px vertical offset
                                            overflow: {
                                                adjustX: true,
                                                adjustY: false // Prevent vertical adjustment (force downward)
                                            }
                                        }
                                    }),
                                    container
                                );
                            };
                            
                            renderOrgSelector();
                        } else {
                            // Fallback to regular select
                            const select = document.createElement('select');
                            select.id = 'org-selector';
                            select.className = 'btn btn-secondary';
                            select.style.width = '100%';
                            
                            // Add options
                            options.forEach(opt => {
                                const option = document.createElement('option');
                                option.value = opt.value;
                                option.textContent = opt.label;
                                if (opt.value === activeConnectionId) {
                                    option.selected = true;
                                }
                                select.appendChild(option);
                            });
                            
                            // Add change handler
                            select.addEventListener('change', async (e) => {
                                const newConnectionId = e.target.value;
                                if (newConnectionId && newConnectionId !== activeConnectionId) {
                                    // Show loading state
                                    document.getElementById('loading').style.display = 'flex';
                                    document.getElementById('hierarchy-container').innerHTML = '';
                                    
                                    try {
                                        // Use the login endpoint to switch connections
                                        const loginResponse = await fetch('/api/login', {
                                            method: 'POST',
                                            headers: {
                                                'Content-Type': 'application/json'
                                            },
                                            body: JSON.stringify({
                                                connection_id: newConnectionId
                                            })
                                        });
                                        
                                        if (loginResponse.ok) {
                                            // Reload the page to use the new connection
                                            location.reload();
                                        } else {
                                            const error = await loginResponse.json();
                                            alert(`Failed to switch organization: ${error.error || 'Unknown error'}`);
                                            // Reset to the active connection
                                            select.value = activeConnectionId;
                                            document.getElementById('loading').style.display = 'none';
                                        }
                                    } catch (error) {
                                        console.error('Error switching organization:', error);
                                        alert('Failed to switch organization. Please try again.');
                                        select.value = activeConnectionId;
                                        document.getElementById('loading').style.display = 'none';
                                    }
                                }
                            });
                            
                            container.appendChild(select);
                        }
                    } else {
                        // No connections found
                        const container = document.getElementById('org-selector-container');
                        container.innerHTML = '<span style="color: #999;">No saved connections</span>';
                    }
                } else {
                    // Error loading connections
                    const container = document.getElementById('org-selector-container');
                    container.innerHTML = '<span style="color: #999;">Error loading connections</span>';
                }
            } catch (error) {
                console.error('Error in loadOrgSelector:', error);
                console.error('Error details:', error.message, error.stack);
                const container = document.getElementById('org-selector-container');
                container.innerHTML = '<span style="color: #999;">Error loading connections</span>';
            }
        }

        // Global toolbar functions
        function zoomIn() {
            if (window.hierarchySvg && window.hierarchyZoom) {
                window.hierarchySvg.transition().duration(300).call(window.hierarchyZoom.scaleBy, 1.2);
            }
        }
        
        function zoomOut() {
            if (window.hierarchySvg && window.hierarchyZoom) {
                window.hierarchySvg.transition().duration(300).call(window.hierarchyZoom.scaleBy, 0.8);
            }
        }
        
        function resetView() {
            if (window.hierarchySvg && window.hierarchyZoom) {
                window.hierarchySvg.transition().duration(300).call(window.hierarchyZoom.transform, d3.zoomIdentity.translate(100, 50));
            }
        }
        
        function fitToScreen() {
            if (!window.hierarchySvg || !window.hierarchyRoot) return;
            
            // Get the bounding box of all visible nodes
            const nodes = window.hierarchyRoot.descendants().filter(d => d.x !== undefined && d.y !== undefined);
            if (nodes.length === 0) return;
            
            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            nodes.forEach(d => {
                minX = Math.min(minX, d.x);
                maxX = Math.max(maxX, d.x + 200); // Add node width
                minY = Math.min(minY, d.y);
                maxY = Math.max(maxY, d.y + 60); // Add node height
            });
            
            // Get container dimensions
            const container = document.getElementById('hierarchy-container');
            const width = container.clientWidth;
            const height = container.clientHeight;
            
            // Calculate scale to fit
            const padding = 50;
            const scaleX = (width - padding * 2) / (maxX - minX);
            const scaleY = (height - padding * 2) / (maxY - minY);
            const scale = Math.min(scaleX, scaleY, 1); // Don't zoom in more than 100%
            
            // Calculate translation to center
            const centerX = (minX + maxX) / 2;
            const centerY = (minY + maxY) / 2;
            const translateX = width / 2 - centerX * scale;
            const translateY = height / 2 - centerY * scale;
            
            // Apply transform
            window.hierarchySvg.transition().duration(500)
                .call(window.hierarchyZoom.transform, d3.zoomIdentity
                    .translate(translateX, translateY)
                    .scale(scale));
        }
        
        // Initialize on page load
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOM loaded');
            
            // Initialize inline editor and change tracker
            if (window.inlineEditor && window.changeTracker) {
                window.inlineEditor.changeTracker = window.changeTracker;
                window.inlineEditor.initialize();
            }
            
            // Load org selector
            loadOrgSelector();
            
            // Immediately use D3 visualization
            console.log('Using D3 visualization');
            
            // Hide loading and fetch data
            document.getElementById('loading').style.display = 'none';
            const container = document.getElementById('hierarchy-container');
            container.innerHTML = '';
            
            // Fetch and render
            fetch('/api/product-hierarchy')
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    console.log('Data received:', data);
                    if (data.success && data.hierarchy) {
                        // Store original data for filtering
                        originalData = data.hierarchy;
                        currentData = JSON.parse(JSON.stringify(originalData));
                        
                        // Restore filter preferences from sessionStorage
                        const savedActiveFilter = sessionStorage.getItem('hierarchy-activeFilter');
                        const savedSyncedOnly = sessionStorage.getItem('hierarchy-syncedOnly');
                        
                        if (savedActiveFilter) {
                            document.getElementById('activeFilter').value = savedActiveFilter;
                        }
                        if (savedSyncedOnly !== null) {
                            document.getElementById('syncedOnlyFilter').checked = savedSyncedOnly === 'true';
                        }
                        
                        // Apply filters if any are set
                        if ((savedActiveFilter && savedActiveFilter !== 'all') || savedSyncedOnly === 'true') {
                            applyFilters();
                        } else {
                            renderD3Tree(currentData);
                        }
                    } else {
                        // No hierarchy data - show option to load sample data
                        container.innerHTML = `
                            <div class="empty-state" id="empty-state">
                                <i class="fas fa-inbox"></i>
                                <p>No hierarchy data available</p>
                                <button class="btn btn-primary" onclick="loadSampleData()">
                                    Load Sample Data
                                </button>
                            </div>
                        `;
                    }
                })
                .catch(error => {
                    console.error('Error loading data:', error);
                    console.error('Error details:', error.message, error.stack);
                    
                    // Show option to load sample data
                    container.innerHTML = `
                        <div class="empty-state" id="empty-state">
                            <i class="fas fa-exclamation-triangle"></i>
                            <p>Error loading hierarchy data</p>
                            <p style="font-size: 0.875rem; color: #999; margin-bottom: 1rem;">${error.message}</p>
                            <button class="btn btn-primary" onclick="loadSampleData()">
                                Load Sample Data
                            </button>
                        </div>
                    `;
                });
        });
    </script>
</body>
</html>